<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="baidu-site-verification" content="codeva-QrWma6zDc2"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: Make-A-Little-Progress-Every-Day - 神奇宝贝大师的技术博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="HeyFL"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="HeyFL"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="神奇宝贝大师的技术博客"><meta property="og:url" content="https://heyfl.gitee.io/"><meta property="og:site_name" content="神奇宝贝大师的技术博客"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://heyfl.gitee.io/img/og_image.png"><meta property="article:author" content="神奇宝贝大师"><meta property="article:tag" content="博客 bolg Spring JVM Java内存结构 分布式 事务 分布式事务 redis MQ 消息队列"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://heyfl.gitee.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://heyfl.gitee.io"},"headline":"神奇宝贝大师的技术博客","image":["https://heyfl.gitee.io/img/og_image.png"],"author":{"@type":"Person","name":"神奇宝贝大师"},"publisher":{"@type":"Organization","name":"神奇宝贝大师的技术博客","logo":{"@type":"ImageObject","url":"https://heyfl.gitee.io/img/avatar.png"}},"description":null}</script><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="神奇宝贝大师的技术博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about/about.html">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://heyfl.github.io"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">Make-A-Little-Progress-Every-Day</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-09-05T06:44:56.000Z" title="9/5/2018, 2:44:56 PM">2018-09-05</time>发表</span><span class="level-item"><time datetime="2023-04-04T18:53:50.407Z" title="4/5/2023, 2:53:50 AM">2023-04-05</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Make-A-Little-Progress-Every-Day/">Make-A-Little-Progress-Every-Day</a></span><span class="level-item">1 小时读完 (大约12116个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day.html">每天进步一点点（持续更新）</a></p><div class="content" id="article"><blockquote><p><b style="color:red;font-size:18px">[原创]</b>这篇只是做点记录备忘，个人理解，请批判接受，有误请指正。转载请注明出处: <a href="#">https://heyfl.gitee.io/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day.html</a></p></blockquote><h2 id="2022-10-25">2022-10-25</h2><h3 id="目前本地缓存使用的方式">目前本地缓存使用的方式</h3><ul><li>订运单系统： SF自研的类Ehcache框架，存储的内容不是特别多，都是一些网点月结卡号信息，所有对象存在于Map，占200m左右</li><li>SISP系统： 使用了Caffeine，存储的内容，存储的内容很多，包括员工表（900m），人员表（bdus 800m） 客户表（1.2g），用户及权限相关表（500m）<ul><li>关联后约占4g内存，目前采用Caffeine默认存储方式，启动即全量加载（极个别采用懒加载方式加载），全部存在于Map中，即堆存储</li></ul></li></ul><blockquote><p>优化: 缓存为基础数据，数据量稳定，目前采用CMS回收器，堆空间8g，缓存存于堆中，占约4g，平时MajorGC达4~6s，曾出现高峰gc达52s，<br> <s>应考虑将缓存存于堆外，减少GC的压力，提升性能（风险点，可能会导致内存溢出）</s> <code>后面自己论证时行不通...因为java对象存到堆外时需要额外进行序列化，经测试，这会导致对象明显变大，浪费的内存有点多，在降本增效的背景下是行不通的</code></p></blockquote><p>参考 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cnblogs.com/wudiffs/p/11585757.html">guava、caffeine、ohc（堆外缓存）详解</a></p><h2 id="2022-10-20">2022-10-20</h2><h3 id="Spring中最常用的11个扩展点">Spring中最常用的11个扩展点</h3><ul><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://juejin.cn/post/7145084738775023646">Spring中最常用的11个扩展点</a></li></ul><h2 id="2022-09-02">2022-09-02</h2><h3 id="Hystrix熔断配置">Hystrix熔断配置</h3><p>为让Hystrix的熔断降级配置更加合理，会议讨论结果需进行如下优化，</p><ol><li>为每个已有Hystrix熔断的接口设置最高并发配置（execution.isolation.semaphore.maxConcurrentRequests），配置200~500之间，具体计算方式<br> 单节点线程数 = QPS /节点数/ ( 1000 / 被熔断方法的P99耗时ms )<br> 翻译：方法单节点线程并发数 = QPS /节点数/1s内该方法能执行次数</li><li>把Hystrix配置提取到disconf，重启生效，无需发版</li></ol><p>QPS和RT的关系：<br> 对于单线程：QPS=1000/P99<br> 对于多线程：QPS=1000<em>线程数量/P99<br> 对于多线程多接点：QPS=1000</em>单节点线程数量*节点数量/P99</p><h2 id="2022-08-11">2022-08-11</h2><h3 id="前端跨域请求减少Option请求">前端跨域请求减少Option请求</h3><p>后端对CorsConfiguration配置Access-Control-Max-Age，前端请求时接收到Access-Control-Max-Age，在该有效时间内不会再发出Option请求</p><blockquote><p>CorsConfiguration config = new CorsConfiguration();<br> config.setMaxAge(600L);</p></blockquote><blockquote><p>后端返回的Access-Control-Max-Age 大于浏览器支持的最大值 那么取浏览器最大值作为缓存时间<br> 否则取后端返回的Access-Control-Max-Age作为缓存时间<br> 缓存时间内不会再发option请求<br> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://chromium.googlesource.com/chromium/blink/+/master/Source/core/loader/CrossOriginPreflightResultCache.cpp#103">源码</a></p></blockquote><h2 id="2022-06-03">2022-06-03</h2><h3 id="POJO、JavaBeans、BO、DTO-和-VO-、DO之间的区别">POJO、JavaBeans、BO、DTO 和 VO 、DO之间的区别</h3><ul><li>POJO，也称为普通旧 Java 对象，是一个普通的 Java 对象，它没有对任何特定框架的引用。</li><li>JavaBean/BO：有约束的POJO，国内用法一般为BO<blockquote><ul><li>实现Serializable接口</li><li>将属性标记为private</li><li>使用 getter/setter 方法来访问属性</li></ul></blockquote></li><li>DTO：也称为数据传输对象，封装值以在进程或网络之间传输数据。<blockquote><p>DTO 没有任何显式行为。它基本上有助于通过将域模型与表示层解耦来使代码松散耦合</p></blockquote></li><li>VO：外国作为值对象，不过国内用法是用来做视图对象，主要是返回前端用的对象</li><li>DO(Data Object) ，持久化对象，数据库对象</li></ul><h2 id="2021-06-01">2021-06-01</h2><h3 id="System-arraycopy方法和Arrays-copyOf">System.arraycopy方法和Arrays.copyOf()</h3><ul><li>System.arraycopy方法：是本地方法，如果是数组比较大，那么使用System.arraycopy会比较有优势，因为其使用的是内存复制，省去了大量的数组寻址访问等时间</li><li>Arrays.copyOf()<ol><li>Arrays.copyOf()在System.arraycopy()实现的基础上提供了额外的功能</li><li>会创建新数组</li><li>允许与原数组类型不同，但是这样会调用JVM的反射，性能较差</li></ol></li></ul><h2 id="2021-05-20">2021-05-20</h2><h3 id="ES-分词">ES 分词</h3><ul><li>text：用于全文索引，该类型的字段将通过分词器进行分词，最终用于构建索引</li><li>keyword：不分词，只能搜索该字段的完整的值，只~~~~用于条件精准查询</li></ul><blockquote><p>通常情况都以 keyworkd 字段进行搜索，因为全文索引的分词器不一定能够完全分词，可能会导致搜索不准确，所以一般都是用 keyword 字段进行搜索</p></blockquote><h2 id="2021-02-26">2021-02-26</h2><h3 id="HBASE-列族-RowKey">HBASE 列族,RowKey</h3><p>HBase是一种面向列的数据库,以row+列名作为key，data作为value，依次存放 假如某一行的某一个列没有数据，则直接跳过该列。对于稀疏矩阵的大表，HBase能节省空间</p><ul><li>表是行的集合</li><li>行是列族的集合</li><li>列族是列的集合</li><li>列是键值对的集合</li></ul><h2 id="2021-02-08">2021-02-08</h2><h3 id="最近要搞懂的事情">最近要搞懂的事情</h3><ul><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cnblogs.com/029zz010buct/p/10366775.html">MySQL、HBase、ES的特点和区别</a></li></ul><ol><li>redo log和checkpoint机制</li></ol><blockquote><p>单机情况下，MySQL的innodb通过redo log和checkpoint机制来保证数据的完整性。因为怕log越写越大，占用过多磁盘，而且当log特别大的时候，恢复起来也比较耗时。而checkpoint的出现就是为了解决这些问题。</p></blockquote><ol start="2"><li>mysql主从架构<br> Master-Slave(主挂了可能会丢失一部分数据)和Group Replication 的架构(mgr采用paxos协议实现了数据节点的强同步，保证了所有节点都可以写数据，并且所有节点读到的也是最新的数据)</li></ol><h2 id="2021-02-07">2021-02-07</h2><h3 id="稍稍记录一下2020年干过的那些P大点的事">稍稍记录一下2020年干过的那些P大点的事</h3><ol><li>协助完成Redis降存储–&gt;阉割无用字段,(没用上压缩) ,以前是存储整个对象,现在是存储个别有用的字段, 降低了60%~80%的存储<ul><li>综合订单、CX、操作运单、公共redis，共节省redis资源9034G</li></ul></li><li>团队共同完成灰度发版–&gt;中间加应用,数据先到分流应用,通过分流应用把对应城市、网点的数据分流到对应的应用</li><li>独立完成ES查询优化–&gt;优化判断索引逻辑,指定查询具体某个分片,提高性能550倍</li><li>生产某个节点线程数过多及CPU高–&gt;dump&amp;排查源码 elasticJob的采用了流式处理,有某个节点的一些线程一直能查到数据,就一直继续工作了;</li><li>elastic-job流式处理导致最终只有一个线程在跑的问题排查&amp;修复 —&gt; 同上</li><li>重试模块加入根据重试次数逃生逻辑,防止异常时空跑把系统跑死</li><li>优化ES存储订单数据的结构 —&gt; 4亿+数据量减少到只剩下5kw数据量，降低了十倍左右</li></ol><ul><li>把orderExtendInfoList类型改为keyword类型（原来为嵌套类型）, 内部额外存储一个作为索引用的值为原orderExtendInfo的key和value对应的Map</li></ul><blockquote><p>描述起来比较麻烦 大概是把下图左边的变成变成右边的</p></blockquote><div align="center"><img src="/images/a-little-progress/es索引优化1.png" alt="es索引优化1"></div><h3 id="数据造就业务—-咋玩">数据造就业务—&gt;咋玩???</h3><ol><li>目前手上有啥数据:</li></ol><ul><li><p>订单–&gt;可以对BSP客户进行分类, 对不同类型客户,可以特别推荐一些增值服务或产品<br> -----&gt;根据寄件商品的类型为其推荐增值服务<br> 扩展信息…没啥用<br> 增值服务</p></li><li><p>订单状态&lt;—监控? 存在很多很久不揽收的 进行告警通知小哥? 让其决定是取消，还是让其再设定一个较远的预约时间</p></li><li><p>FVP所有状态&lt;–</p></li><li><p>运单号生成</p></li><li><p>运单&lt;—</p></li><li><p>产品变更&lt;— 变更监控? 至少可以记录一下产品变化以及运费变化</p></li></ul><h2 id="2021-01-25">2021-01-25</h2><h3 id="一、ZK事件回调原理-–-最近用得少老是忘记，还是记录一下吧">一、ZK事件回调原理 – 最近用得少老是忘记，还是记录一下吧</h3><blockquote><p>简单来说，就是客户端启动后，会在zk注册一个watcher监听某个我们关心的节点Node的变化；<br> 同时客户端会把这个watcher存到本地的WatcherManager里;<br> 当这个节点出现变化，zk会通知到对应的客户端，调用该watcher的回调方法（process方法）。</p><p>以此方式实现动态配置平台的配置刷新下发、分布式锁等功能</p></blockquote><h2 id="2020-12-14">2020-12-14</h2><h3 id="一、-ElasticSearch原理">一、 ElasticSearch原理</h3><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://zhuanlan.zhihu.com/p/187503928">图解ElasticSearch原理</a></p><ul><li>精确查询</li></ul><blockquote><p>term 查询是如何工作的？ Elasticsearch 会在倒排索引中查找包括某 term 的所有文档</p></blockquote><ul><li>Lucene Index(包含多个Segments)：</li></ul><blockquote><p>Segments 是不可变的（immutable）：<br> Segments Delete？当删除发生时，Lucene 做的只是将其标志位置为删除，但是文件还是会在它原来的地方，不会发生改变。<br> Segments Update？所以对于更新来说，本质上它做的工作是：先删除，然后重新索引（Re-index）<br> 随处可见的压缩：Lucene 非常擅长压缩数据，基本上所有教科书上的压缩方式，都能在 Lucene 中找到<br> 缓存所有的所有：Lucene 也会将所有的信息做缓存，这大大提高了它的查询效率</p></blockquote><ul><li>整体结构</li></ul><blockquote><p>Cluster由多个Node节点组成<br> 每个Node节点由多个索引Index组成<br> 每个索引由多个Share组成<br> 每个Share(又叫Lucene Index)存在于集群中多个Node中,具体有多少个Share,看你索引的配置,由多个Segment组成<br> 每个Segment(又称Mini索引),每个Segment都是不可变的,只会生成一个增量Segment(含修改后的/新增的数据),原来的数据只能标记为删除,当Segment多了之后会做merge合并操作;</p></blockquote><ul><li>Segments的创建&amp;刷新 (没玩大数据 大概了解就行了)</li></ul><blockquote><p>进行索引文档后,看是否有达到flush条件的Segment,存在就flush该Segment将该数据刷到硬盘中,没找到就创建一个Segment??<br> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cnblogs.com/vsop/p/10162326.html">参考 -&gt; ES lucene写入流程，segment产生机制源码分析</a></p></blockquote><h2 id="2020-11-18">2020-11-18</h2><h3 id="一、-MYSQL是怎么运行的-–-连接原理">一、 MYSQL是怎么运行的 – 连接原理</h3><p>–以下为内连接,驱动表为t1,如果t1通过where过滤完还有2条数据,那么会去t2表查询2次<br> select * from t1 join t2 where ***;<br> select * from t1 inner join t2 where ***;<br> select * from t1 cross join t2 where ***;<br> (以上等价于)select * from t1,t2 where ***;</p><p>select * from t1 left join t2 on t1.a=t2.a where ***; – 为外连接</p><p>on实际是给外连接用的,在内连接使用的话和where的作用是一样的;<br> 在外连接中使用,如果匹配不上,不会过滤掉驱动表原有的值;如果要过滤掉这种连接不上的值,可以再加个where条件过滤</p><p>驱动表t1只会被访问一次，被驱动表t2会被访问多次</p><h2 id="2020-09-24-好久没做记录了…">2020-09-24(好久没做记录了…)</h2><h3 id="一、-DB-看似匹配到索引-但是没有走索引的情况-注意事项">一、 DB 看似匹配到索引,但是没有走索引的情况(注意事项)</h3><p style="color:red;font-size:20px;font-weight:700">因类型转换导致不走索引</p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962432&amp;idx=1&amp;sn=3459e82428cb9bb1de4677fa6b5a1c2d&amp;chksm=bd2d099c8a5a808af5926a8be9c900c0bca57a8b8e61b192272d919e38d607a03b5ac4e0990a&amp;scene=21#wechat_redirect">摘自本文结论内容</a></p><ol><li><strong>建表语句cell的数据类型为Varchar</strong></li></ol><blockquote><p>create table t (<br> id int(20) primary key AUTO_INCREMENT,<br> cell <b style="color:red;font-size:18px;font-weight:700">varchar(20)</b> unique<br> )engine=innodb;<br> <b>建表的时候cell定义的是字符串类型</b></p></blockquote><ol start="2"><li><strong>Explain</strong></li></ol><div align="center"><img src="/images/DB执行计划&排查/update索引执行计划.png" alt="update索引执行计划"></div><blockquote><p>通过explain，基本已经可以判断：<br> update t set cell=456 where cell=55555555555;<br> 并没有和我们预想一样，走cell索引进行查询，而是走了PK索引进行了全表扫描。</p></blockquote><ol start="3"><li><strong>实际问题</strong></li></ol><blockquote><p>where语句cell类型与索引的不匹配，不会走索引，最终会走全表；</p></blockquote><ol start="4"><li><strong>结论</strong></li></ol><blockquote><p style="color:red;font-size:20px;font-weight:700">类型转换，会导致全表扫描，出现锁升级，锁住全部记录</p></blockquote><h3 id="二、-DB-执行计划查看-死锁排查">二、 DB 执行计划查看&amp;&amp;死锁排查</h3><h4 id="执行计划">执行计划</h4><div align="center"><img src="/images/DB执行计划&排查/update索引执行计划.png" alt="update索引执行计划"></div><ul><li><p><strong>select_type：SIMPLE</strong><br> 这是一个简单类型的SQL语句，不含子查询或者UNION。</p></li><li><p><strong>type：index</strong><br> 访问类型，即找到所需数据使用的遍历方式，潜在的方式有：<br> （1）ALL（Full Table Scan）：全表扫描；<br> （2）index：走索引的全表扫描；<br> （3）range：命中where子句的范围索引扫描；<br> （4）ref/eq_ref：非唯一索引/唯一索引单值扫描；<br> （5）const/system：常量扫描；<br> （6）NULL：不用访问表；<br> 上述扫描方式，ALL最慢，逐步变快，NULL最快。</p></li><li><p><strong>possible_keys：NULL</strong><br> 可能在哪个索引找到记录。</p></li><li><p><strong>key：PRIMARY</strong><br> 实际使用索引。</p></li><li><p><strong>ref：NULL</strong><br> 哪些列，或者常量用于查找索引上的值。</p></li><li><p><strong>rows：5</strong><br> 找到所需记录，预估需要读取的行数。</p></li></ul><h4 id="死锁排查">死锁排查</h4><ul><li>有权限的mysql账户执行:<blockquote><p style="color:red;font-size:20px;font-weight:700">show engine innodb status;</p></blockquote></li><li>根据查到的结果 分析LATEST DETECTED DEADLOCK里的内容</li></ul><h3 id="三、ES-提高查询效率">三、ES 提高查询效率</h3><p>学习自: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/es-optimizing-query-performance.md">ES 在数据量很大的情况下（数十亿级别）如何提高查询效率</a></p><div align="center"><img src="/images/ES/ES方式.png" alt="ES查询原理"></div><ol><li>把尽可能多的索引放在<code>filesystem cache</code>中</li><li>不做复杂查询（Join等），如果有这样的需要，应以设计得更好的document（记录）来实现简单查询（单表）</li><li>使用ES+hbase架构:<br> ES存索引，索引全放在<code>filesystem cache</code>，数据存HBase；通过ES进行条件查询，获取docId，用该docId去查HBase</li><li>禁止深度查询，使用scrollApi或search_after代替</li></ol><h3 id="四、ES存储结构">四、ES存储结构</h3><div align="center"><img src="/images/ES/ES存储结构.png" alt="ES存储结构"></div><blockquote><p style="color:red;font-size:20px;font-weight:700">index -> type -> mapping -> document -> field</p></blockquote><blockquote><p>实例： order~2020-08-02/order/_mapping/记录/字段<br> 翻译： 索引名称/表名/表结构/记录/字段</p></blockquote><h2 id="2019-12-19">2019-12-19</h2><h3 id="Kafka">Kafka</h3><ol><li><strong>基础点</strong></li></ol><blockquote><p>Topic&amp;消费组:<br> <strong>一个Topic的一个Partition只能一个Consumer Group的一个节点消费</strong><br> 一个【Topic】对应多个【Partition】(文件)<br> 消息大小限制:<br> 一条消息 默认最大只能为1000000B(976.56 kB),所以一般规定不允许发送&gt;900k的消息</p></blockquote><ol start="2"><li>版本区别:</li></ol><blockquote><p>0.8版本 (相对历史版本 支持了Replication高可用 )<br> 当时只有Consumer Coordinator<br> coordinator需要依赖于ZK，通过zk监听/consumers/<group>/ids变化 与 brokers/topic的数据变化决定是否要 rebalanced<br> rebalanced后,consumer自己决定自己要消费哪些Partition，然后抢先在/consumers/<group>/owners/<topic>/<partition>下注册（<b style="color:red;font-size:14px">通过这种方式实现一个Topic的一个Partition只能一个Consumer Group的一个节点消费`）</b><br> 同时,各个Consumer Coordinator还需要进行位移的提交</partition></topic></group></group></p><p>弊端: 消费者自己决定消费哪些分区,各个Consumer Coordinator还需要进行位移的提交<br> 并且分区的决定与位移的提交都需要依赖于ZK</p><p>0.8.2版本<br> 0.8.2版本开始同时支持将 offset 存于 Zookeeper 中与将offset 存于专用的Kafka Topic 中,但是需要<b style="color:red;font-size:14px">High Level API</b>的支持，且BUG较多，目前公司用的还是<b style="color:red;font-size:14px">Low Level Api</b></p><p>0.9.x版本<br> 新增Group Coordinator,存在于Broker端<br> 代替了0.8.x版本的zk，每个消费组对应一个，负责每个消费者位移的提交&amp;分区消费的决策</p><p>0.10+<br> 消息结构添加了时间戳，可根据这个时间戳实现延迟队列</p><p>0.11.x版本<br> 新增了对【幂等】、【事务】的支持(依赖于Producer幂等) (exactly-once)</p></blockquote><p>3.High Level和Low Level</p><blockquote><ul><li><s>将仅支持zookeeper维护offset方式的</s> 高级抽象的API称为 <b style="color:red;font-size:14px">Low Level Api</b>,高度抽象,</li><li><s>将支持kafka broker 维护offset方式</s> 抽象低的API的称为 <b style="color:red;font-size:14px">High Level API</b> ，<br> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://blog.csdn.net/WangQYoho/article/details/78358715">High level consumer vs. Low level consumer</a><br> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://kafka.apache.org/08/documentation.html#simpleconsumerapi">官方解释(看最下面的描述)</a></li></ul></blockquote><ol start="4"><li>消息(生产)幂等</li></ol><blockquote><p>每个Topic的每个Partition对每个生产者都维护了一套ID(UUID)<br> 生产者每次发送消息时候,消息体都带上这个ID+1，以此Broker可得知：</p><ul><li>当消息的squence number等于broker维护的squence number + 1，表示消息有序且第一次消费</li><li>当消息的squence number小于或等于broker维护的squence number，表示重复消费额</li><li>当消息的squence number等于broker维护的squence number + n（n &gt; 1），表示存在消息丢失<br> <a target="_blank" rel="external nofollow noopener noreferrer" href="http://codingcms.cn/2019/10/13/kafka_1/">参考1:Kafka Producer 幂等的原理</a><br> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960002&amp;idx=1&amp;sn=c0775231bccf002c3178eabe43f1cdcb&amp;chksm=bd2d071e8a5a8e08c3a5287247ea41dee6b2621e6ffafbf909ec1e8a866b7c816eeeea227246&amp;scene=21#wechat_redirect">参考2:上半场的幂等性设计</a></li></ul></blockquote><ol start="5"><li>消息的分区选择:</li></ol><blockquote><p>一条消息会根据Key被路由到某一【Partition】（key=0对应分区0）；如果没有指定key，消息会被均匀的分配到所有分区；目前我们封装的方案是，不管有没有Key，都会被随机打乱到每个分区）<br> 每隔 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://topic.metadata.refresh.interval.ms">topic.metadata.refresh.interval.ms</a> 的时间，随机选择一个partition。这个时间窗口内的所有记录发送到这个partition。发送数据出错后也会重新选择一个partition<br> 对key求hash，然后对partition数量求模: <b style="color:red;font-size:14px">Utils.abs(key.hashCode) % numPartitions</b><br> 代码: <b style="color:red;font-size:14px">kafka.producer.async.DefaultEventHandler#handle</b></p></blockquote><ol start="6"><li>Kafka支持的消息发送模式</li></ol><blockquote><p>At most once 消息可能会丢，但绝不会重复传输(例:读到先Commit,再处理)<br> At least one 消息绝不会丢，但可能会重复传输(例:读到先处理,再Commit)<br> Exactly once 每条消息肯定会被传输一次且仅传输一次，很多时候这是用户所想要的 (<b style="color:red;font-size:14px">0.8.2版本还不支持</b>)</p></blockquote><ol start="7"><li><p>高可用<br> kafka默认会重试3次</p></li><li><p>零碎小点</p><ol><li>Kafka实现的是客户端软负载: 让producer决定丢到哪个partition里</li><li>Consumer端仅支持pull模式，这也有利于让Consumer端决定消费速率</li><li>Consumer不能消费太久(如Sleep),因为Kafka会认为程序宕了,分区会重新进行分配,把消息分给其他的Consumer (相关配置项: <a target="_blank" rel="external nofollow noopener noreferrer" href="http://max.poll.interval.ms">max.poll.interval.ms</a>)</li><li>Consumer每次可从Kafka取max.poll.records条数据进行处理</li><li>如果想要消息有序 那么就得保证同个业务key的消息都是发到1个分区里</li></ol></li></ol><h3 id="Redis-Sentinel-Jedis">Redis-Sentinel&amp;Jedis</h3><h4 id="通过Sentinel集群获取Redis主节点原理">通过Sentinel集群获取Redis主节点原理</h4><blockquote><p>SF-Sentinel中配置Redis链(mymaster1,mymaster2,mymaster3)，然后获取每一条链的Master，进行初始化Redis连接池<br> 原生的Sentinel中配置Redis链，然后获取该链的Master，进行初始化Redis连接池</p></blockquote><h4 id="Jedie的Key是如何被存入Redis的某个节点的">Jedie的Key是如何被存入Redis的某个节点的</h4><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://my.oschina.net/xinxingegeya/blog/391713">参考:Jedis之ShardedJedis一致性哈希分析</a></p><blockquote><p>Jedis初始化时会初始化160个虚拟节点，160个虚拟节点通过Map（Map&lt;ShardInfo<r>, R&gt; resources）映射到实际的Redis-Master节点<br> Jedis在Set key时会对Key分片计算（计算落在160个节点的哪一个），然后再根据虚拟节点与实际节点的映射，把指令发给实际的节点<br> 参考代码：<br> redis.clients.util.Sharded#initialize<br> redis.clients.util.Sharded#getShard(byte[])</r></p></blockquote><h4 id="Redis-Sentinel模式是如何扩容的">Redis-Sentinel模式是如何扩容的</h4><p>空</p><h4 id="Jedis一致性分析">Jedis一致性分析</h4><div align="center"><img src="/images/Redis-Sentinel扩容/Jedis一致性分析.png" alt="Jedis一致性分析"></div><h2 id="2019-11-28">2019-11-28</h2><h3 id="git-rebase-i-HEAD-2">git rebase -i HEAD~2</h3><blockquote><p><code>pick：保留该commit（缩写:p）</code><br> <code>reword：保留该commit，但我需要修改该commit的注释（缩写:r）</code><br> <code>edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）</code><br> <code>squash：将该commit和前一个commit合并（缩写:s）</code><br> <code>fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）</code><br> <code>exec：执行shell命令（缩写:x）</code><br> <code>drop：我要丢弃该commit（缩写:d）</code></p></blockquote><h3 id="Hibernate-基本知识">Hibernate 基本知识</h3><ul><li>inverse属性表示本实体是否拥有主动权<br> <code>inverse只有在非many方才有，也就是many-to-many或者one-to-many的set,List等</code></li></ul><h2 id="2019-11-25">2019-11-25</h2><h3 id="数据库count"><strong>数据库count()</strong></h3><h4 id="官方解释">官方解释</h4><blockquote><p><code>Returns a count of the number of non-NULL values of expr in the rows retrieved by a SELECT statement. The result is a BIGINT value.</code><br> 返回行中 expr 的非 NULL 值的计数</p></blockquote><h4 id="count-和-count-1">count(*) 和 count(1)</h4><blockquote><p>5.7.18以后，两个函数执行计划都是一样的</p><ul><li>如果该表没有任何索引，那么会扫描全表，统计行数</li><li>如果该表只有一个主键索引，没有任何二级索引的情况下，那么通过主键索引来统计行数的</li><li>如果该表有二级索引，则会通过占用空间最小的字段的二级索引进行统计</li></ul></blockquote><h4 id="count-column）">count(column）</h4><blockquote><p>如果字段定义为not null，则按行累加，如果允许有null，则会把值取出来判断一下是不是null，将不是null的值累加返回。</p></blockquote><h4 id="MyISAM-与-InnoDB">MyISAM 与 InnoDB</h4><ul><li>MyISAM会记录每个表的行数，count()时直接返回</li><li>InnoDB会通过扫描全表或索引，得到行数</li><li>在使用count函数中加上where条件时，在两个存储引擎中的效果是一样的，都会扫描全表计算某字段有值项的次数</li></ul><h4 id="DB-select-count速度">DB select count速度</h4><blockquote><p>count(*)=count(1)&gt;count(primary key)&gt;count(column)</p></blockquote><h4 id="参考">参考</h4><p><a target="_blank" rel="external nofollow noopener noreferrer" href="http://baijiahao.baidu.com/s?id=1645061957944427225&amp;wfr=spider&amp;for=pc">MySQL原理：count(*)为什么这么慢，带你重新认识count的方方面面</a></p><h2 id="2019-11-22">2019-11-22</h2><h3 id="垂直-分库分表"><strong>[垂直]分库分表</strong></h3><h4 id="目标"><strong>目标</strong></h4><blockquote><p>通过减少数据量，提升性能</p></blockquote><h4 id="原则"><strong>原则</strong></h4><ul><li>长度较短，访问频率较高的属性尽量放在一个表里，我们将其称为主表<code>(base表)</code></li><li>字段较长，访问频率较低的属性尽量放在一个表里，我们将其称为扩展表<code>(ext表)</code></li><li>经常一起访问的属性，也可以放在一个表里<code>(备选)</code></li></ul><h4 id="大数据量场景注意事项"><strong>大数据量场景注意事项</strong></h4><ul><li><strong>不能用Join</strong><br> <strong>解决方式: 让应用自己拆分成两次查询</strong></li></ul><blockquote><ul><li>base表和ext表不能Join，因为一旦Join了，那么两张表就出现了耦合，这不利于日后拆表到别的数据库实例上</li><li>Join很消耗数据库的性能<code>(分布式场景下,瓶颈往往是数据库)</code></li></ul></blockquote><h4 id="提高性能的原理"><strong>提高性能的原理</strong></h4><ul><li>减少单表的数据量，减少磁盘IO<code>（降低每行记录大小）</code></li><li>更好的利用缓存</li></ul><blockquote><p>因为减少单表数据量还可以充分利用数据库缓存，减少磁盘IO</p></blockquote><h2 id="2019-11-20">2019-11-20</h2><h3 id="数据库基本知识"><strong>数据库基本知识</strong></h3><h4 id="MyISAM与InnoDB索引的区别">MyISAM与InnoDB索引的区别</h4><p>MyISAM:</p><ul><li>MyISAM不存在聚集索引,主键索引与普通索引没区别，叶子节点都是存储的都是<strong>数据的地址</strong></li></ul><p>InnoDB:</p><ul><li>InnoDB必然有[一个]聚集索引<code>（为主键索引,没主键时会用第一个非空普通索引，都没有会生成一个基于行号的聚集索引）</code></li></ul><blockquote><p>select * from t where name=‘lisi’;<br> 会先通过name辅助索引定位到B+树的叶子节点得到id=5，再通过聚集索引定位到行记录</p></blockquote><div align="center"><img src="/images/a-little-progress/InnoDB索引方式.png" alt="InnoDB命中普通索引获取数据方式"></div><p>违反唯一索引场景:<br> MyISAM会出现<strong>一个update语句，部分执行成功，部分执行失败</strong><code>(因为不支持事务)</code></p><h2 id="2019-11-11">2019-11-11</h2><h3 id="Elastic-Job"><strong>Elastic-Job</strong></h3><ol><li>运行规则:<blockquote><p>3台机器的一个集群 ,shardingCount=10 ,分片结果为：1=[0,1,2,9], 2=[3,4,5], 3=[6,7,8] (参考<code>AverageAllocationJobShardingStrategy</code>)<br> 如果本机的数据分片分到了多个分片（即一个JVM进程分到了多个分片），则Elastic-Job会为每一个分片去启动一个线程来执行分片任务</p></blockquote></li><li>线程:<blockquote><p>每个任务对应一个线程池,其默认线程数为: 2*逻辑核心数(参考<code>DefaultExecutorServiceHandler</code>)<br> 线程池配置为: <code>new ThreadPoolExecutor(threadSize, threadSize, 5L, TimeUnit.MINUTES, workQueue, new BasicThreadFactory.Builder().namingPattern(Joiner.on(&quot;-&quot;).join(namingPattern, &quot;%s&quot;)).build());</code> (参考<code>ExecutorServiceObject</code>)</p></blockquote></li><li>问题:<blockquote><p>要注意单机线程数要 大于 单机获取到的分片数 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.jianshu.com/p/0d0e7339c9b0">- 参考 《Elastic job 线程模型 源码分析》</a><br> 一个jvm实例 处理多个 job ， 每个job 在该实例上分片数又大于逻辑核心数*2 的数量<br><br> 随着job不断增加 ， 单个job任务执行时间可能会变长 ，有可能超过平时的任务完成超时时间 ，造成任务失败</p><p>举个例子:<br> 如果一台机器 处理器数 2 ， 线程池 就是 4 ， 如果 分片是 5 ， 就是说 一个分片会被排队 ，实际完成时间 &gt;2 个分片 完成时间</p></blockquote></li></ol><h3 id="Elastic-Job其他">Elastic-Job其他</h3><h4 id="1-失效转移">1. 失效转移</h4><blockquote><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cnblogs.com/haoxinyue/p/7068115.html">- 参考</a></p></blockquote><ol><li><p>【简单的HA】版失效转移 (默认)<br> 在作业节点下线，或者zk的session超时（默认60s）时，会在下一轮任务分片时，把这个该问题节点的分片分给别的正常节点进行作业 （<code>可能会存在作业重复处理的问题</code>）</p></li><li><p>【真正的】'失败’转移 (需要开启)<br> 当<code>failover（默认值为false）</code> 配置为<code>true</code>时，才会启动真正的失效转移；<br> 当<code>failover（默认值为false）</code> 和 <code>monitorExecution（默认值是true）</code>这两个配置都为true时 只有对<code>monitorExecution</code>为<code>true</code>的情况下才可以开启失效转移；<br> 如果任务1在A节点执行【失败】，那么会【转移】给别的存活的节点【竞争】执行这个任务1；</p></li></ol><blockquote><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cnblogs.com/kevin-yuan/p/7017795.html">- 参考</a><br> <a target="_blank" rel="external nofollow noopener noreferrer" href="http://elasticjob.io/docs/elastic-job-lite/03-design/lite-design/">- 官方参考</a></p></blockquote><h2 id="2019-08-26">2019-08-26</h2><blockquote><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/innodb-record-level-locks.html">官方参考</a></p></blockquote><h3 id="MySQL锁">MySQL锁</h3><blockquote><ul><li>InnoDB锁机制是基于索引建立的</li><li>如果SQL语句中匹配不到索引,那么就会升级为表锁</li></ul></blockquote><h4 id="记录锁">记录锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- id 列为主键列或唯一索引列</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> age<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p>通过唯一索引实现的记录锁,只会锁住当前记录(必须为<code>=</code>不然会退化为<code>临键锁</code>)</p></blockquote><h4 id="间隙锁">间隙锁</h4><blockquote><ul><li><strong>间隙锁<font color="red" size="5">只有</font>在事务隔离级别 <font color="red" size="5">RR(可重复读)</font>中才会生效</strong>.</li><li>为非唯一索引组成(如class,age等)</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> student <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">26</span> <span class="keyword">and</span> age<span class="operator">&lt;</span><span class="number">28</span> lock <span class="keyword">in</span> share mode ; <span class="comment">-- 这里以读锁为例</span></span><br></pre></td></tr></table></figure><h5 id="使用间隙锁的条件">使用间隙锁的条件</h5><ul><li>命中普通索引锁定；</li><li>使用多列唯一索引；</li><li>使用唯一索引命中多行记录</li></ul><h5 id="临键锁-Next-key-Locks">临键锁(Next-key Locks)</h5><ul><li><strong>临键锁<font color="red" size="5">只有</font>在事务隔离级别 <font color="red" size="5">RR(可重复读)</font>中才会生效</strong>.</li><li>是记录锁与间隙锁的组合</li><li>可以是<code>唯一索引</code>,也可以是<code>非唯一索引</code>,对其都以间隙锁的形式进行锁定(<code>以唯一索引匹配,并且只匹配到一条数据除外</code>)</li></ul><h6 id="临键锁-Next-key-Locks-例子">临键锁(Next-key Locks) 例子:</h6><table><thead><tr><th>tno<code>(唯一索引)</code></th><th>tname</th><th>tsex</th><th>tbirthday</th><th>prof</th><th>depart</th><th>age<code>(非唯一索引)</code></th></tr></thead><tbody><tr><td>858</td><td>张旭</td><td>1</td><td>1969-03-12</td><td>讲师</td><td>电子工程系</td><td>25</td></tr><tr><td>857</td><td>张旭</td><td>女1</td><td>1969-03-12</td><td>讲师</td><td>电子工程系</td><td>25</td></tr><tr><td>856</td><td>张旭</td><td>男</td><td>1969-03-12</td><td>讲师</td><td>电子工程系</td><td>25</td></tr><tr><td>831</td><td>刘冰</td><td>女</td><td>1977-08-14</td><td>助教</td><td>电子工程系</td><td>29</td></tr><tr><td>825</td><td>王萍</td><td>女</td><td>1972-05-05</td><td>助教</td><td>计算机系</td><td>28</td></tr><tr><td>804</td><td>李诚</td><td>男</td><td>1958-12-02</td><td>副教授</td><td>计算机系</td><td>26</td></tr></tbody></table><blockquote><p>其中有唯一索引的<code>临键</code>为:<br> (-∞,804]<br> (804,825]<br> (825,831]<br> (831,856]<br> (856,857]<br> (857,858]<br> (858,+∞]</p></blockquote><blockquote><p>其中有非唯一索引的<code>临键</code>为:<br> (-∞,25]<br> (25,26]<br> (26,28]<br> (28,29]<br> (29,+∞]</p></blockquote><h6 id="非唯一索引临键锁验证"><strong><code>非唯一索引</code>临键锁验证</strong></h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher <span class="keyword">WHERE</span> age <span class="keyword">between</span> <span class="number">26</span> <span class="keyword">and</span> <span class="number">28</span> lock <span class="keyword">in</span> share mode ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这时候会锁定非唯一索引的<code>临键</code> <code>(25,29]</code><br> 所以我们测试更新age=25–&gt;成功 插入age=27阻塞 更新age=29阻塞 插入age=30成功即可验证</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session2</span></span><br><span class="line"><span class="comment">-- 更新age=25--&gt;成功</span></span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> tsex<span class="operator">=</span><span class="string">&#x27;女1&#x27;</span> <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入age=27阻塞</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `test`.`teacher` ( `tno`, `tname`, `tsex`, `tbirthday`, `prof`, `depart`,`age`) <span class="keyword">values</span> ( <span class="string">&#x27;740&#x27;</span>, <span class="string">&#x27;张旭1&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;1969-03-12 00:00:00&#x27;</span>, <span class="string">&#x27;讲师&#x27;</span>, <span class="string">&#x27;电子工程系&#x27;</span>,<span class="number">27</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新age=29--&gt;阻塞</span></span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> tsex<span class="operator">=</span><span class="string">&#x27;女1&#x27;</span> <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">29</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新age=30--&gt;成功</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `test`.`teacher` ( `tno`, `tname`, `tsex`, `tbirthday`, `prof`, `depart`,`age`) <span class="keyword">values</span> ( <span class="string">&#x27;740&#x27;</span>, <span class="string">&#x27;张旭1&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;1969-03-12 00:00:00&#x27;</span>, <span class="string">&#x27;讲师&#x27;</span>, <span class="string">&#x27;电子工程系&#x27;</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure><h6 id="唯一索引临键锁验证"><strong><code>唯一索引</code>临键锁验证</strong></h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher <span class="keyword">WHERE</span> tno <span class="keyword">between</span> &quot;831&quot; <span class="keyword">and</span> &quot;856&quot; lock <span class="keyword">in</span> share mode ;</span><br></pre></td></tr></table></figure><blockquote><p>根据上面的sql,我们匹配到<code>唯一索引</code>临键锁为:<code>(825,857]</code><br> 所以我们测试更新tno=825–&gt;成功 更新tno=857阻塞 更新age=858成功即可验证</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更新tno=&quot;825&quot;--&gt;成功</span></span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> tsex<span class="operator">=</span><span class="string">&#x27;女1&#x27;</span> <span class="keyword">WHERE</span> tno<span class="operator">=</span>&quot;825&quot;;</span><br><span class="line"><span class="comment">-- 更新tno=&quot;857&quot;--&gt;阻塞</span></span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> tsex<span class="operator">=</span><span class="string">&#x27;女1&#x27;</span> <span class="keyword">WHERE</span> tno<span class="operator">=</span>&quot;857&quot;;</span><br><span class="line"><span class="comment">-- 更新tno=&quot;858&quot;--&gt;成功</span></span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> tsex<span class="operator">=</span><span class="string">&#x27;女1&#x27;</span> <span class="keyword">WHERE</span> tno<span class="operator">=</span>&quot;858&quot;;</span><br></pre></td></tr></table></figure><h2 id="2019-08-22">2019-08-22</h2><h3 id="Spring事务-AOP增强">Spring事务/AOP增强</h3><ul><li><code>@EnableAspectJAutoProxy(exposeProxy = true)</code></li></ul><ol><li>进入代理时,通过<code>AopContext.serCurrentProxy(proxy)</code>把当前代理设置到ThreadLocal中</li><li>后续在线程销毁(请求结束)前调用代理内部之间的调用就可以通过<code>((AService)AopContext.currentProxy()).b()</code>进行调用了</li><li>PS. 性能影响不大 不过实际上代理内部之间还需要AOP增强的场景不多,一般没必要用</li></ol><h3 id="Spring-LTW实现的静态织入（应该不能叫做代理）">Spring LTW实现的静态织入<code>（应该不能叫做代理）</code></h3><blockquote><ul><li>需要添加配置：</li></ul><ol><li>代码添加: <code>@EnableLoadTimeWeaving(aspectjWeaving=ENABLED)</code>或<code>&lt;context:load-time-weaver aspectj-weaving=&quot;enable&quot; /&gt;</code></li><li>添加JVM参数<code>-javaagent:类加载器代理路径</code></li></ol></blockquote><ol><li><p><code>LTW(LoadTime Weaving)</code><br> 加载时织入。在通过JVM加载类时候会先调用<code>ClassTransformer</code>的<code>transform()</code>进行字节码替换后才会进行加载。</p></li><li><p><code>静态AOP</code><br> 通过<code>LTW</code>可以实现<code>静态AOP</code>增强，加载到的类就是已经增强后的代码。这样我们调用方法的时候,直接就是调用了增强后的方法,比起动态代理的调用,更加地高效。</p></li></ol><p>上述流程大致如下所示:</p><pre class="mermaid">graph TD
A[Target]
B[增强后的字节码]
C[加载后的代码]
D[注入后的Bean]
E[调用方]
A--ClassTransformer的transform方法进行字节码植入-->B
B--JVM加载-->C
C--Spring使用,创建/注入Bean-->D
E--方法调用-->D</pre><h2 id="2019-08-01">2019-08-01</h2><h3 id="Spring事务">Spring事务</h3><blockquote><p>对于this.b()这些类实例的内部调用，b()实际上是无事务的<br> 但是可以用<code>((AService)AopContext.currentProxy()).b()</code> 结合<code>@EnableAspectJAutoProxy(exposeProxy = true)</code> 这样b()就包裹在事务里了</p></blockquote><h2 id="2019-7-20">2019-7-20</h2><h3 id="seata">seata</h3><ul><li>seata需要管理所有的数据库操作，不然不能通过前镜像进行回滚</li></ul><h2 id="2019-7-17">2019-7-17</h2><h3 id="Spring事务-Cglib">Spring事务/Cglib</h3><ol><li>final,static,private修饰符无法被增强</li></ol><blockquote><p>由于使用final,static,private修饰符的方法都不能被子类覆盖，相应的，这些方法将不能被实施的AOP增强</p></blockquote><ol start="2"><li>增强应该作用在实现类中</li></ol><blockquote><p>@Transactional 注解可以作用于接口、接口方法、类以及类方法上，<strong><font color="red" size="5">但是 Spring 建议不要在接口或者接口方法上使用该注解</font></strong>，<font color="red">因为这只有在使用基于接口的代理时它才会生效</font>。</p></blockquote><h2 id="2019-5-20">2019-5-20</h2><h3 id="【GC日志】GC耗时解析">【GC日志】GC耗时解析</h3><blockquote><p>【Time: user=0.71 sys=0.01 real=0.02 secs】</p><ol><li>user表示：本次GC过程中【所有线程】在用户态消耗的时间总和</li><li>sys表示： 本次GC过程中 【所有线程】在内核态所消耗的时间总和</li><li>real表示：本次GC过程中，实际GC消耗的时间</li></ol></blockquote><h2 id="2019-5-1">2019-5-1</h2><h3 id="数据库MVCC">数据库MVCC</h3><blockquote><ul><li>MVCC：多版本并发控制(Multi-Version Concurrency Control)</li><li>优势：查询速度快，并发环境尤是。<strong><font color="red">对于大多数读操作，我们只需要通过MVCC进行简单的查询操作，而不需要获取任何一个<code>锁</code>。</font></strong></li><li>劣势：需要多存储数据。<strong><font color="blue">对每一条记录都需要存储所有版本的数据</font></strong></li><li><strong><font color="red">MVCC只工作在REPEATABLE READ和READ COMMITED隔离级别下</font></strong></li><li>READ UNCOMMITED不是MVCC兼容：因为这个模式只能读取到最新的数据</li><li>SERIABLABLE也不与MVCC兼容：因为每个读操作都需要为读到的数据上锁</li></ul></blockquote><h2 id="事务"><img src="/images/a-little-progress/db-transactional-note.png" alt="事务"></h2><h4 id="MVVC机制：">MVVC机制：</h4><blockquote><ul><li>以下摘自<a target="_blank" rel="external nofollow noopener noreferrer" href="https://mp.weixin.qq.com/s/vRf5p9c9_4GrmFLaqEZI6w">《五分钟搞清楚 MVCC 机制》</a></li></ul></blockquote><ol><li><p>每一条数据库表记录,都隐藏2个字段</p><ul><li>数据行的版本号 （DB_TRX_ID）</li><li>删除版本号 (DB_ROLL_PT)</li></ul></li><li><p>执行insert语句插入的时候,会把当前的事务ID写到该记录的数据行的版本号 （DB_TRX_ID）中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;-- 获取到全局事务ID 假设为2</span><br><span class="line">insert into `test_zq` (`id`, `test_id`) values(&#x27;5&#x27;,&#x27;68&#x27;);</span><br><span class="line">commit;-- 提交事务</span><br></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>test_id</th><th>DB_TRX_ID</th><th>DB_ROLL_PT</th></tr></thead><tbody><tr><td>5</td><td>68</td><td>2</td><td>NULL</td></tr><tr><td>6</td><td>78</td><td>1</td><td>3</td></tr></tbody></table></li><li><p>修改数据库记录的时候</p><ol><li>更新原记录的删除版本号 (DB_ROLL_PT)为当前事务ID</li><li>插入一行新的更新后的记录,且它的数据行的版本号 （DB_TRX_ID）为当前事务ID</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;-- 获取全局系统事务ID 假设为 10</span><br><span class="line">update test_zq set test_id = 22 where id = 5;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>test_id</th><th>DB_TRX_ID</th><th>DB_ROLL_PT</th></tr></thead><tbody><tr><td>5</td><td>68</td><td>2</td><td>10</td></tr><tr><td>6</td><td>78</td><td>1</td><td>3</td></tr><tr><td>5</td><td>22</td><td>10</td><td>NULL</td></tr></tbody></table></li><li><p>查询的时候需要根据<code>数据行的版本号 （DB_TRX_ID）</code> 和 <code>删除版本号 (DB_ROLL_PT)</code> 二者进行数据数据筛选，需要同时满足以下规则：</p><ol><li><code>数据行的版本号 （DB_TRX_ID）</code> &lt;= 当前事务</li><li><code>删除版本号 (DB_ROLL_PT)</code> &gt; 当前事务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;-- 假设拿到的系统事务ID为 10</span><br><span class="line">select * from test_zq;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>test_id</th><th>DB_TRX_ID</th><th>DB_ROLL_PT</th></tr></thead><tbody><tr><td>6</td><td>22</td><td>10</td><td>NULL</td></tr></tbody></table></li></ol><h2 id="2019-04-24">2019-04-24</h2><h3 id="Spring的Lifecycle-SpringAppilication生命周期">Spring的Lifecycle (SpringAppilication生命周期)</h3><blockquote><p>Spring会拿到所有Lifecycle实现类，然后委托DefaultLifecycleProcessor进行逐个处理</p></blockquote><ul><li>Lifecycle 可以在SpringAppilication在初始化后执行start()方法,Spring停止的时候调用stop()方法</li><li>但是单单实现该类不能实现SpringAppilication在启动后,停止时调用Lifecycle对应的方法</li><li>这时候我们应该需要使用SmartLifecycle（Lifecycle的子类）,重写isAutoStartup()返回true，才能产生理想效果</li></ul><h2 id="2019-04-23">2019-04-23</h2><h3 id="关于测试类的规范">关于测试类的规范</h3><ol><li>单元测试应该是不依赖于别的单元测试的</li><li>所有单元测试应该都得回滚，如果存在异步处理的情况，应尽可能把主线程与fork线程拆成2个测试类方法进行测试</li><li>每个测试类／测试方法应写上对应的名称@DisplayName</li><li>每个接口，都必须写一个正向测试方法</li><li>关于测试类的类名：测试类与被测试的类的路径需要一致，名字也需要对应，如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.fpx.wms.service.impl.InstockServiceImpl</span><br><span class="line">↓对应↓</span><br><span class="line">com.fpx.wms.service.impl.InstockServiceImplTest</span><br></pre></td></tr></table></figure><ol start="6"><li>关于测试类的方法名： 方法名尽可能为成功的条件如shouldSuccessAfterPay()，而方法具体用来测试哪个场景的，我们已经使用了@ DisplayName来描述，无须担心</li><li>对于结果，需要适应assert断言输出与结</li></ol><h2 id="2019-04-22">2019-04-22</h2><h3 id="Spring-Lookup">Spring @Lookup</h3><h4 id="作用">作用</h4><blockquote><p>在单例A里 可能依赖到原型类型B,这时候如果用普通的Autowrite不能拿到原型的B，这时候就需要使用@Lockup了</p></blockquote><h4 id="使用参考">使用参考</h4><ul><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://wangxiang5050.github.io/reading/2018/05/29/spring-lookup/">参考地址</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.baeldung.com/spring-lookup">官网地址参考地址</a></li></ul><h2 id="2019-04-21">2019-04-21</h2><h3 id="架构设计三大原则">架构设计三大原则</h3><ul><li>合适原则</li><li>简单原则</li><li>演化原则</li></ul><blockquote><p>即，合适优于先进，简单优于复杂，演化优于一步到位<br> →能不分，尽可能不分</p></blockquote><h2 id="2019-03-20">2019-03-20</h2><h3 id="策略模式-vs-命令模式">策略模式 vs 命令模式</h3><h4 id="1-策略模式">1. 策略模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">策略模式针对一个命令,多种实现方式</span><br></pre></td></tr></table></figure><h4 id="2-命令模式">2. 命令模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令模式针对多个命令,每种命令都有各自的实现</span><br></pre></td></tr></table></figure><h4 id="3-总结">3. 总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令模式等于菜单中的复制，移动，压缩等，而策略模式是其中一个菜单的例如复制到不同算法实现。</span><br></pre></td></tr></table></figure><h2 id="2019-03-15">2019-03-15</h2><h3 id="策略模式-vs-代理模式">策略模式 vs 代理模式</h3><h4 id="1-策略模式-v2">1. 策略模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要调用方告知具体的策略</span><br></pre></td></tr></table></figure><h4 id="2-代理模式">2. 代理模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要调用方告知使用哪个[代理类]</span><br><span class="line">具体的【被代理类】由【代理类】生成，客户端不知道具体被代理的是谁</span><br></pre></td></tr></table></figure><h4 id="2-1-动态代理">2.1 动态代理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要调用方告知[被代理类]及其接口</span><br></pre></td></tr></table></figure><h4 id="3-One-More-Thing">3.One More Thing</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">以上模式都需要客户端告知具体的[策略]/[代理]/[被代理者]</span><br><span class="line">为了使实现其与调用方进行隔离,可以使用[**工厂模式**]进行隔离</span><br></pre></td></tr></table></figure><h2 id="2019-03-12">2019-03-12</h2><h3 id="Spring循环依赖">Spring循环依赖</h3><p><code>场景现有3个类相互依赖，依赖关系分别为：</code></p><pre class="mermaid">graph LR
A-->B
B-->C
C-->A</pre><p><code>场景细分为3种</code></p><ol><li>构造注入参数循环依赖(报错)<br> 报错</li></ol><blockquote><p>根据Spring初始化方式,Spring容器会按照顺序创建&quot;无属性&quot;的A放到<font size="1" color="red">“当前创建Bean池”</font>中，同理再B、C、A，但是在再次创建A的时候发现<font size="1" color="red">“当前创建Bean池”</font>已经存在A了，那么这时候会报错循环依赖</p></blockquote><ol start="2"><li>Setter注入的循环依赖(<code>单例</code>)</li></ol><blockquote><p>没毛病，在set的时候对象ABC都已经实例化放在Spring缓存了好了</p></blockquote><ol start="3"><li>Setter注入的循环依赖(<code>prototype</code>)<br> 报错</li></ol><blockquote><p><code>prototype</code>修饰的bean不会被Spring缓存,都是使用的时候当场创建的</p></blockquote><h3 id="Spring注入方式选择">Spring注入方式选择</h3><p>结合上面的循环依赖问题，Setter出现问题的概率会低一些 推荐使用Setter注入</p><ol><li>构造注入</li><li>Setter注入</li><li>接口注入(没用过)</li></ol><h2 id="2019-03-11">2019-03-11</h2><h3 id="一、集合操作">一、集合操作</h3><h4 id="遍历">遍历</h4><ol><li>Enumeration(JDK1.0)<ul><li>只提供读集合相关功能，因为没有fail-fast，速度较快一点</li></ul></li><li>Iterator(<font color="red">推荐</font>)<ul><li>除了读功能，还有删除集合元素的能力，并且支持fail-fast（防止多线程同时对集合修改的一种机制）</li></ul></li></ol><h4 id="修改">修改</h4><p><font color="grean">正例：</font><br><br> 以List为例子,先得获取他的Iterator,通过iterator来进行修改操作<br><br><br> <font color="red">反例：</font><br><br> 使用增强型foreach进行add/remove操作：</p><blockquote><p>因为增强型foreach实际上是使用iterator实现的java语法糖:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;test12&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;test13&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;test14&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (String userName : userNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userName.equals(<span class="string">&quot;test12&quot;</span>)) &#123;</span><br><span class="line">        userNames.remove(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译后</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.add(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.add(<span class="string">&quot;test12&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.add(<span class="string">&quot;test13&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.add(<span class="string">&quot;test14&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">var1</span> <span class="operator">=</span> userNames.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> (String)var1.next();</span><br><span class="line">    <span class="keyword">if</span> (userName.equals(<span class="string">&quot;test12&quot;</span>)) &#123;</span><br><span class="line">        userNames.remove(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">所以实际上for (String userName : userNames) 这里每次都会去调用itertor.next()</span><br><span class="line">如果你在迭代期间,操作了list.add()和list.remove()等不通过Iterator的操作</span><br><span class="line">next()里会去调用checkForComodification()方法</span><br><span class="line">然后发现modCount != expectedModCount 抛出异常</span><br><span class="line"></span><br><span class="line">因为list.add()和list.remove()等不通过Iterator的操作,是不会修改expectedModCount的</span><br></pre></td></tr></table></figure><h4 id="其它">其它</h4><ul><li><code>fail-fast：</code></li></ul><blockquote><p>防止多线程同时对集合修改的一种机制<br></p></blockquote><ul><li><code>modCount：</code></li></ul><blockquote><p>****List**中的一个成员变量。它表示该集合实际被修改的次数</p></blockquote><ul><li><code>expectedModCount：</code></li></ul><blockquote><p>是 ****List**中的一个内部类——<font size="3" color="red">Itr中的成员变量</font></p></blockquote><h3 id="二、Hystrix">二、Hystrix</h3><ol><li>Feign-starter包含Hystrix以及ribbon(只用他的均衡负载 http请求还是用feign自己的)</li><li>一个@FeignClient对应一个线程池或信号量</li><li>隔离<ul><li>线程池隔离</li></ul><blockquote><p><strong>tomcat的请求线程会交给线程池的线程处理</strong><br> 超过线程池会排队或者降级，一个线程池对应的服务挂了，不会影响别的线程池的服务</p></blockquote><ul><li>信号量隔离</li></ul><blockquote><p><strong>只作为开关</strong><br> 并发数超过X服务的信号量,多出来的Tomcat请求将会被拒绝</p></blockquote></li></ol><hr><h2 id="2019-03-09">2019-03-09</h2><p><img src="/images/a-little-progress/data-struct.png" alt="img.png"></p><h2 id="2019-03-05">2019-03-05</h2><h3 id="一、StringBuilder在高性能场景下的正确用法">一、StringBuilder在高性能场景下的正确用法</h3><p><a target="_blank" rel="external nofollow noopener noreferrer" href="http://nathanchen.github.io/14596982516208.html">StringBuilder在高性能场景下的正确用法(文中代码打错了一些字…)</a></p><ul><li>正确写法应该是这样↓<br> <a href="/file/stringbuilderdemo/StringBuilderUtil.java">StringBuilderUtil.java</a></li></ul><h2 id="2019-03-01">2019-03-01</h2><h3 id="一、分布式锁">一、分布式锁</h3><blockquote><p>从需求上说，分布式锁要求是不一样的：</p><ol><li>如果是用于聊天等社交场景,那么可以使用AP的分布式锁:Redis</li><li>如果是用于交易等不允许极端情况下获取锁不一致的，那么AP的Redis锁是不能接受的，这时候一定得用CP的分布式锁,如:etcd Zookeeper这一类</li></ol></blockquote><h2 id="2019-02-22">2019-02-22</h2><h3 id="一、ThreadLocal">一、ThreadLocal</h3><p><img src="/images/%E5%B9%B6%E5%8F%91/ThreadLocal.png" alt="ThreadLocal数据结构"><br> <img src="/images/a-little-progress/ThreadLocal2.png" alt="ThreadLocal引用关系.png"></p><ol><li><p><strong><font color="red" size="4">每个线程都有一个ThreadLocalMap</font></strong>,ThreadLocalMap以Entry的形式保存着各个线程自己的数据</p></li><li><p>Entry为一个WeakReference,以你new的ThreadLocal为Key</p></li><li><p>基于2.当你new的ThreadLocal没被外部强引用时,线程该Thread下对应该ThreadLocal的Entry会在下次GC被回收</p></li><li><p>当一条线程创建了多个ThreadLocal，多个ThreadLocal放入ThreadLocalMap 会极大地增加冲突概率</p></li><li><p>ThreadLocalMap对冲突的处理方式与普通HashMap的链表处理不一样，而是以原来的位置+1，一直寻找到没有冲突的地方存入</p></li><li><p>ThreadLocal在ThreadLocalMap中是以一个弱引用身份被Entry中的Key引用的</p></li><li><p>ThreadLocal.remove(),移除ThreadLocalMap与Entry的关系，释放内存</p></li></ol><h2 id="2019-02-17">2019-02-17</h2><h3 id="一、常量池">一、常量池</h3><p>常量池包含:</p><ol><li>class常量池 存在于class文件中</li><li>运行时常量池 存在于方法区中 一个类对应一个运行时常量池</li><li>字符串常量池 全局唯一 JDK6存在于方法区(独立于运行时常量池) JDK6以后存在于堆中</li></ol><h3 id="二、字符串加载到字符串常量池的2种方式">二、字符串加载到字符串常量池的2种方式</h3><pre class="mermaid">graph LR
A[编译后的class文件中的class常量池]
B[运行时常量池*N]
C[字符串常量池]
D[Java代码运行]
A-->B
D-->B
B-->C</pre><h2 id="2019-01-28">2019-01-28</h2><h3 id="Mybatis">Mybatis</h3><h4 id="一级缓存">一级缓存</h4><blockquote><p>(范围为一个SqlSession)<br> 有Session/STATEMENT级别:</p></blockquote><ul><li>默认是SESSION 级别，即在一个MyBatis会<br> 话中执行的所有语句，都会共享这一个缓存。</li><li>一种是STATEMENT 级别，可以理解为缓存只对当前执行的<br> 这一个Statement 有效</li></ul><h4 id="二级缓存">二级缓存</h4><blockquote><p>基于mapper<br> 二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享</p></blockquote><ul><li>补充: 缓存为本地缓存, 在集群部署的系统里开启后,会导致A1查询与A2查询结果不一致的问题 看情况开启,一般为关闭;或者使用Redis等工具使用统一的第三方缓存</li></ul><h2 id="2018-11-06">2018-11-06</h2><h3 id="一、-分布式事物要看场景的">一、 分布式事物要看场景的</h3><p>举个例子:</p><blockquote><ol><li>流量充值涉及到订单支付，金钱交易严格用tcc;</li><li>订单支付完后要给用户增加积分，这个必要成功，用最终消息一致性方案;</li><li>订单支付完后还要给用户发送一条短信，短信一般是跟电信运营商的第三方接口对接，有可能成功有可能失败，用最大努力通知方案</li></ol></blockquote></div><a class="article-more button is-small is-size-7" href="/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day.html#more">阅读更多</a></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Pokémon Master"></figure><p class="title is-size-4 is-block" style="line-height:inherit">Pokémon Master</p><p class="is-size-6 is-block">Web Developer &amp; Designer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>ShenZhen, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">62</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">17</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">35</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://heyfl.github.io/" target="_blank" rel="external nofollow noopener noreferrer">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Github" href="https://github.com/HeyFL"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="QQ(361389383)" href="tencent://message/?uin=361389383"><i class="fab fa-qq"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Bug-Log-Optimization/"><span class="level-start"><span class="level-item">Bug-Log&amp;Optimization</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Distributed/"><span class="level-start"><span class="level-item">Distributed</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/MQ/"><span class="level-start"><span class="level-item">MQ</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Make-A-Little-Progress-Every-Day/"><span class="level-start"><span class="level-item">Make-A-Little-Progress-Every-Day</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/about/"><span class="level-start"><span class="level-item">about</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/bookmarks/"><span class="level-start"><span class="level-item">bookmarks</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/code-rules/"><span class="level-start"><span class="level-item">code-rules</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/database/"><span class="level-start"><span class="level-item">database</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/design/"><span class="level-start"><span class="level-item">design</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/dubbo/"><span class="level-start"><span class="level-item">dubbo</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/framework-design/"><span class="level-start"><span class="level-item">framework-design</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/redis/"><span class="level-start"><span class="level-item">redis</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/system/"><span class="level-start"><span class="level-item">system</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/web/"><span class="level-start"><span class="level-item">web</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/"><span class="level-start"><span class="level-item">2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/"><span class="level-start"><span class="level-item">2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/1970/"><span class="level-start"><span class="level-item">1970</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/BUG/"><span class="tag">BUG</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Code-Rule/"><span class="tag">Code-Rule</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Consul/"><span class="tag">Consul</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DATABASE/"><span class="tag">DATABASE</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ElasticSearch/"><span class="tag">ElasticSearch</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hbase/"><span class="tag">Hbase</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hystrix/"><span class="tag">Hystrix</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JAVA/"><span class="tag">JAVA</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"><span class="tag">JVM内存结构</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KAFKA/"><span class="tag">KAFKA</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kafka/"><span class="tag">Kafka</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LOCK/"><span class="tag">LOCK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MQ/"><span class="tag">MQ</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MYCAT/"><span class="tag">MYCAT</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MYSQL/"><span class="tag">MYSQL</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mybatis/"><span class="tag">Mybatis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/REDIS/"><span class="tag">REDIS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SYSTEM/"><span class="tag">SYSTEM</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring-Cloud/"><span class="tag">Spring-Cloud</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/design/"><span class="tag">design</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dubbo/"><span class="tag">dubbo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis%E9%9B%86%E7%BE%A4/"><span class="tag">redis集群</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BC%98%E5%8C%96/"><span class="tag">优化</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80/"><span class="tag">基础</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"><span class="tag">架构设计</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AF%8F%E5%A4%A9%E8%BF%9B%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9/"><span class="tag">每天进步一点点</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%99%BD%E6%9D%BF/"><span class="tag">白板</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"><span class="tag">知识点整理</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"><span class="tag">高并发</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="神奇宝贝大师的技术博客" height="28"></a><p class="is-size-7"><span>&copy; 2023 神奇宝贝大师</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a></p><p class="is-size-7">用💖发电</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="HeyFl GitHub" href="https://heyfl.github.io/"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.bootcdn.net/ajax/libs/mermaid/8.0.0/mermaid.min.js"></script><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/print-js/1.6.0/print.min.css"><script src="https://cdn.bootcdn.net/ajax/libs/print-js/1.6.0/print.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer="defer"></script><script>moment.locale("zh-cn")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer="defer"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer="defer"></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer="defer"></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer="defer"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer="defer"></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"right",width:80,height:150},mobile:{show:!1}})</script></body></html>