<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>每天进步一点点 - 基础技术篇 | 花火笔记</title><meta name="author" content="花火"><meta name="copyright" content="花火"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[原创]这篇只是做点记录备忘，个人理解，请批判接受，有误请指正。转载请注明出处: https:&#x2F;&#x2F;heyfl.gitee.io&#x2F;Make-A-Little-Progress-Every-Day&#x2F;Make-A-Little-Progress-Every-Day-Basic-Technology.html   本文不怎么更新了  2022-10-25 目前本地缓存使用的方式  订运单系统： SF自研"><meta property="og:type" content="article"><meta property="og:title" content="每天进步一点点 - 基础技术篇"><meta property="og:url" content="https://heyfl.gitee.io/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day-Basic-Technology.html"><meta property="og:site_name" content="花火笔记"><meta property="og:description" content="[原创]这篇只是做点记录备忘，个人理解，请批判接受，有误请指正。转载请注明出处: https:&#x2F;&#x2F;heyfl.gitee.io&#x2F;Make-A-Little-Progress-Every-Day&#x2F;Make-A-Little-Progress-Every-Day-Basic-Technology.html   本文不怎么更新了  2022-10-25 目前本地缓存使用的方式  订运单系统： SF自研"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://heyfl.gitee.io/img/img.png"><meta property="article:published_time" content="2099-09-05T06:44:56.000Z"><meta property="article:modified_time" content="2025-12-16T18:26:30.057Z"><meta property="article:author" content="花火"><meta property="article:tag" content="每天进步一点点"><meta property="article:tag" content="知识点整理"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://heyfl.gitee.io/img/img.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "每天进步一点点 - 基础技术篇",
  "url": "https://heyfl.gitee.io/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day-Basic-Technology.html",
  "image": "https://heyfl.gitee.io/img/img.png",
  "datePublished": "2099-09-05T06:44:56.000Z",
  "dateModified": "2025-12-16T18:26:30.057Z",
  "author": [
    {
      "@type": "Person",
      "name": "花火",
      "url": "https://heyfl.gitee.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/img.png"><link rel="canonical" href="https://heyfl.gitee.io/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day-Basic-Technology.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"每天进步一点点 - 基础技术篇",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/img.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fa fa-tag"></i> <span>标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i> <span>其他</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/about.html"><i class="fa-fw fa fa-address-card"></i> <span>关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/images/theme/butterfly.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/favicon.ico" alt="Logo"><span class="site-name">花火笔记</span></a><a class="nav-page-title" href="/"><span class="site-name">每天进步一点点 - 基础技术篇</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i> <span>返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fa fa-tag"></i> <span>标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i> <span>其他</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/about.html"><i class="fa-fw fa fa-address-card"></i> <span>关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">每天进步一点点 - 基础技术篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2099-09-05T06:44:56.000Z" title="发表于 2099-09-05 14:44:56">2099-09-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-16T18:26:30.057Z" title="更新于 2025-12-17 02:26:30">2025-12-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Make-A-Little-Progress-Every-Day/">Make-A-Little-Progress-Every-Day</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id data-flag-title><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote><p><b style="color:red;font-size:18px">[原创]</b>这篇只是做点记录备忘，个人理解，请批判接受，有误请指正。转载请注明出处: <a href="#">https://heyfl.gitee.io/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day-Basic-Technology.html</a></p></blockquote><blockquote><p>本文不怎么更新了</p></blockquote><h2 id="2022-10-25">2022-10-25</h2><h3 id="目前本地缓存使用的方式">目前本地缓存使用的方式</h3><ul><li>订运单系统： SF自研的类Ehcache框架，存储的内容不是特别多，都是一些网点月结卡号信息，所有对象存在于Map，占200m左右</li><li>SISP系统： 使用了Caffeine，存储的内容，存储的内容很多，包括员工表（900m），人员表（bdus 800m） 客户表（1.2g），用户及权限相关表（500m）<ul><li>关联后约占4g内存，目前采用Caffeine默认存储方式，启动即全量加载（极个别采用懒加载方式加载），全部存在于Map中，即堆存储</li></ul></li></ul><blockquote><p>优化: 缓存为基础数据，数据量稳定，目前采用CMS回收器，堆空间8g，缓存存于堆中，占约4g，平时MajorGC达4~6s，曾出现高峰gc达52s，<br> <s>应考虑将缓存存于堆外，减少GC的压力，提升性能（风险点，可能会导致内存溢出）</s> <code>后面自己论证时行不通...因为java对象存到堆外时需要额外进行序列化，经测试，这会导致对象明显变大，浪费的内存有点多，在降本增效的背景下是行不通的</code></p></blockquote><p>参考 <a href="https://www.cnblogs.com/wudiffs/p/11585757.html" rel="external nofollow noopener noreferrer" target="_blank">guava、caffeine、ohc（堆外缓存）详解</a></p><h2 id="2022-10-20">2022-10-20</h2><h3 id="Spring中最常用的11个扩展点">Spring中最常用的11个扩展点</h3><ul><li><a href="https://juejin.cn/post/7145084738775023646" rel="external nofollow noopener noreferrer" target="_blank">Spring中最常用的11个扩展点</a></li></ul><h2 id="2022-09-02">2022-09-02</h2><h3 id="Hystrix熔断配置">Hystrix熔断配置</h3><p>为让Hystrix的熔断降级配置更加合理，会议讨论结果需进行如下优化，</p><ol><li>为每个已有Hystrix熔断的接口设置最高并发配置（execution.isolation.semaphore.maxConcurrentRequests），配置200~500之间，具体计算方式<br> 单节点线程数 = QPS /节点数/ ( 1000 / 被熔断方法的P99耗时ms )<br> 翻译：方法单节点线程并发数 = QPS /节点数/1s内该方法能执行次数</li><li>把Hystrix配置提取到disconf，重启生效，无需发版</li></ol><p>QPS和RT的关系：<br> 对于单线程：QPS=1000/P99<br> 对于多线程：QPS=1000<em>线程数量/P99<br> 对于多线程多接点：QPS=1000</em>单节点线程数量*节点数量/P99</p><h2 id="2022-08-11">2022-08-11</h2><h3 id="前端跨域请求减少Option请求">前端跨域请求减少Option请求</h3><p>后端对CorsConfiguration配置Access-Control-Max-Age，前端请求时接收到Access-Control-Max-Age，在该有效时间内不会再发出Option请求</p><blockquote><p>CorsConfiguration config = new CorsConfiguration();<br> config.setMaxAge(600L);</p></blockquote><blockquote><p>后端返回的Access-Control-Max-Age 大于浏览器支持的最大值 那么取浏览器最大值作为缓存时间<br> 否则取后端返回的Access-Control-Max-Age作为缓存时间<br> 缓存时间内不会再发option请求<br> <a href="https://chromium.googlesource.com/chromium/blink/+/master/Source/core/loader/CrossOriginPreflightResultCache.cpp#103" rel="external nofollow noopener noreferrer" target="_blank">源码</a></p></blockquote><h2 id="2022-06-03">2022-06-03</h2><h3 id="POJO、JavaBeans、BO、DTO-和-VO-、DO之间的区别">POJO、JavaBeans、BO、DTO 和 VO 、DO之间的区别</h3><ul><li>POJO，也称为普通旧 Java 对象，是一个普通的 Java 对象，它没有对任何特定框架的引用。</li><li>JavaBean/BO：有约束的POJO，国内用法一般为BO<blockquote><ul><li>实现Serializable接口</li><li>将属性标记为private</li><li>使用 getter/setter 方法来访问属性</li></ul></blockquote></li><li>DTO：也称为数据传输对象，封装值以在进程或网络之间传输数据。<blockquote><p>DTO 没有任何显式行为。它基本上有助于通过将域模型与表示层解耦来使代码松散耦合</p></blockquote></li><li>VO：外国作为值对象，不过国内用法是用来做视图对象，主要是返回前端用的对象</li><li>DO(Data Object) ，持久化对象，数据库对象</li></ul><h2 id="2021-06-01">2021-06-01</h2><h3 id="System-arraycopy方法和Arrays-copyOf">System.arraycopy方法和Arrays.copyOf()</h3><ul><li>System.arraycopy方法：是本地方法，如果是数组比较大，那么使用System.arraycopy会比较有优势，因为其使用的是内存复制，省去了大量的数组寻址访问等时间</li><li>Arrays.copyOf()<ol><li>Arrays.copyOf()在System.arraycopy()实现的基础上提供了额外的功能</li><li>会创建新数组</li><li>允许与原数组类型不同，但是这样会调用JVM的反射，性能较差</li></ol></li></ul><h2 id="2021-05-20">2021-05-20</h2><h3 id="ES-分词">ES 分词</h3><ul><li>text：用于全文索引，该类型的字段将通过分词器进行分词，最终用于构建索引</li><li>keyword：不分词，只能搜索该字段的完整的值，只~~~~用于条件精准查询</li></ul><blockquote><p>通常情况都以 keyworkd 字段进行搜索，因为全文索引的分词器不一定能够完全分词，可能会导致搜索不准确，所以一般都是用 keyword 字段进行搜索</p></blockquote><h2 id="2021-02-26">2021-02-26</h2><h3 id="HBASE-列族-RowKey">HBASE 列族,RowKey</h3><p>HBase是一种面向列的数据库,以row+列名作为key，data作为value，依次存放 假如某一行的某一个列没有数据，则直接跳过该列。对于稀疏矩阵的大表，HBase能节省空间</p><ul><li>表是行的集合</li><li>行是列族的集合</li><li>列族是列的集合</li><li>列是键值对的集合</li></ul><h2 id="2021-02-08">2021-02-08</h2><h3 id="最近要搞懂的事情">最近要搞懂的事情</h3><ul><li><a href="https://www.cnblogs.com/029zz010buct/p/10366775.html" rel="external nofollow noopener noreferrer" target="_blank">MySQL、HBase、ES的特点和区别</a></li></ul><ol><li>redo log和checkpoint机制</li></ol><blockquote><p>单机情况下，MySQL的innodb通过redo log和checkpoint机制来保证数据的完整性。因为怕log越写越大，占用过多磁盘，而且当log特别大的时候，恢复起来也比较耗时。而checkpoint的出现就是为了解决这些问题。</p></blockquote><ol start="2"><li>mysql主从架构<br> Master-Slave(主挂了可能会丢失一部分数据)和Group Replication 的架构(mgr采用paxos协议实现了数据节点的强同步，保证了所有节点都可以写数据，并且所有节点读到的也是最新的数据)</li></ol><h2 id="2021-02-07">2021-02-07</h2><h3 id="稍稍记录一下2020年干过的那些P大点的事">稍稍记录一下2020年干过的那些P大点的事</h3><ol><li>协助完成Redis降存储–&gt;阉割无用字段,(没用上压缩) ,以前是存储整个对象,现在是存储个别有用的字段, 降低了60%~80%的存储<ul><li>综合订单、CX、操作运单、公共redis，共节省redis资源9034G</li></ul></li><li>团队共同完成灰度发版–&gt;中间加应用,数据先到分流应用,通过分流应用把对应城市、网点的数据分流到对应的应用</li><li>独立完成ES查询优化–&gt;优化判断索引逻辑,指定查询具体某个分片,提高性能550倍</li><li>生产某个节点线程数过多及CPU高–&gt;dump&amp;排查源码 elasticJob的采用了流式处理,有某个节点的一些线程一直能查到数据,就一直继续工作了;</li><li>elastic-job流式处理导致最终只有一个线程在跑的问题排查&amp;修复 —&gt; 同上</li><li>重试模块加入根据重试次数逃生逻辑,防止异常时空跑把系统跑死</li><li>优化ES存储订单数据的结构 —&gt; 4亿+数据量减少到只剩下5kw数据量，降低了十倍左右</li></ol><ul><li>把orderExtendInfoList类型改为keyword类型（原来为嵌套类型）, 内部额外存储一个作为索引用的值为原orderExtendInfo的key和value对应的Map</li></ul><blockquote><p>描述起来比较麻烦 大概是把下图左边的变成变成右边的</p></blockquote><div align="center"><img src="/images/a-little-progress/es索引优化1.png" alt="es索引优化1"></div><h3 id="数据造就业务—-咋玩">数据造就业务—&gt;咋玩???</h3><ol><li>目前手上有啥数据:</li></ol><ul><li><p>订单–&gt;可以对BSP客户进行分类, 对不同类型客户,可以特别推荐一些增值服务或产品<br> -----&gt;根据寄件商品的类型为其推荐增值服务<br> 扩展信息…没啥用<br> 增值服务</p></li><li><p>订单状态&lt;—监控? 存在很多很久不揽收的 进行告警通知小哥? 让其决定是取消，还是让其再设定一个较远的预约时间</p></li><li><p>FVP所有状态&lt;–</p></li><li><p>运单号生成</p></li><li><p>运单&lt;—</p></li><li><p>产品变更&lt;— 变更监控? 至少可以记录一下产品变化以及运费变化</p></li></ul><h2 id="2021-01-25">2021-01-25</h2><h3 id="一、ZK事件回调原理-–-最近用得少老是忘记，还是记录一下吧">一、ZK事件回调原理 – 最近用得少老是忘记，还是记录一下吧</h3><blockquote><p>简单来说，就是客户端启动后，会在zk注册一个watcher监听某个我们关心的节点Node的变化；<br> 同时客户端会把这个watcher存到本地的WatcherManager里;<br> 当这个节点出现变化，zk会通知到对应的客户端，调用该watcher的回调方法（process方法）。</p><p>以此方式实现动态配置平台的配置刷新下发、分布式锁等功能</p></blockquote><h2 id="2020-12-14">2020-12-14</h2><h3 id="一、-ElasticSearch原理">一、 ElasticSearch原理</h3><p><a href="https://zhuanlan.zhihu.com/p/187503928" rel="external nofollow noopener noreferrer" target="_blank">图解ElasticSearch原理</a></p><ul><li>精确查询</li></ul><blockquote><p>term 查询是如何工作的？ Elasticsearch 会在倒排索引中查找包括某 term 的所有文档</p></blockquote><ul><li>Lucene Index(包含多个Segments)：</li></ul><blockquote><p>Segments 是不可变的（immutable）：<br> Segments Delete？当删除发生时，Lucene 做的只是将其标志位置为删除，但是文件还是会在它原来的地方，不会发生改变。<br> Segments Update？所以对于更新来说，本质上它做的工作是：先删除，然后重新索引（Re-index）<br> 随处可见的压缩：Lucene 非常擅长压缩数据，基本上所有教科书上的压缩方式，都能在 Lucene 中找到<br> 缓存所有的所有：Lucene 也会将所有的信息做缓存，这大大提高了它的查询效率</p></blockquote><ul><li>整体结构</li></ul><blockquote><p>Cluster由多个Node节点组成<br> 每个Node节点由多个索引Index组成<br> 每个索引由多个Share组成<br> 每个Share(又叫Lucene Index)存在于集群中多个Node中,具体有多少个Share,看你索引的配置,由多个Segment组成<br> 每个Segment(又称Mini索引),每个Segment都是不可变的,只会生成一个增量Segment(含修改后的/新增的数据),原来的数据只能标记为删除,当Segment多了之后会做merge合并操作;</p></blockquote><ul><li>Segments的创建&amp;刷新 (没玩大数据 大概了解就行了)</li></ul><blockquote><p>进行索引文档后,看是否有达到flush条件的Segment,存在就flush该Segment将该数据刷到硬盘中,没找到就创建一个Segment??<br> <a href="https://www.cnblogs.com/vsop/p/10162326.html" rel="external nofollow noopener noreferrer" target="_blank">参考 -&gt; ES lucene写入流程，segment产生机制源码分析</a></p></blockquote><h2 id="2020-11-18">2020-11-18</h2><h3 id="一、-MYSQL是怎么运行的-–-连接原理">一、 MYSQL是怎么运行的 – 连接原理</h3><p>–以下为内连接,驱动表为t1,如果t1通过where过滤完还有2条数据,那么会去t2表查询2次<br> select * from t1 join t2 where ***;<br> select * from t1 inner join t2 where ***;<br> select * from t1 cross join t2 where ***;<br> (以上等价于)select * from t1,t2 where ***;</p><p>select * from t1 left join t2 on t1.a=t2.a where ***; – 为外连接</p><p>on实际是给外连接用的,在内连接使用的话和where的作用是一样的;<br> 在外连接中使用,如果匹配不上,不会过滤掉驱动表原有的值;如果要过滤掉这种连接不上的值,可以再加个where条件过滤</p><p>驱动表t1只会被访问一次，被驱动表t2会被访问多次</p><h2 id="2020-09-24-好久没做记录了…">2020-09-24(好久没做记录了…)</h2><h3 id="一、-DB-看似匹配到索引-但是没有走索引的情况-注意事项">一、 DB 看似匹配到索引,但是没有走索引的情况(注意事项)</h3><p style="color:red;font-size:20px;font-weight:700">因类型转换导致不走索引</p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962432&amp;idx=1&amp;sn=3459e82428cb9bb1de4677fa6b5a1c2d&amp;chksm=bd2d099c8a5a808af5926a8be9c900c0bca57a8b8e61b192272d919e38d607a03b5ac4e0990a&amp;scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">摘自本文结论内容</a></p><ol><li><strong>建表语句cell的数据类型为Varchar</strong></li></ol><blockquote><p>create table t (<br> id int(20) primary key AUTO_INCREMENT,<br> cell <b style="color:red;font-size:18px;font-weight:700">varchar(20)</b> unique<br> )engine=innodb;<br> <b>建表的时候cell定义的是字符串类型</b></p></blockquote><ol start="2"><li><strong>Explain</strong></li></ol><div align="center"><img src="/images/DB执行计划&排查/update索引执行计划.png" alt="update索引执行计划"></div><blockquote><p>通过explain，基本已经可以判断：<br> update t set cell=456 where cell=55555555555;<br> 并没有和我们预想一样，走cell索引进行查询，而是走了PK索引进行了全表扫描。</p></blockquote><ol start="3"><li><strong>实际问题</strong></li></ol><blockquote><p>where语句cell类型与索引的不匹配，不会走索引，最终会走全表；</p></blockquote><ol start="4"><li><strong>结论</strong></li></ol><blockquote><p style="color:red;font-size:20px;font-weight:700">类型转换，会导致全表扫描，出现锁升级，锁住全部记录</p></blockquote><h3 id="二、-DB-执行计划查看-死锁排查">二、 DB 执行计划查看&amp;&amp;死锁排查</h3><h4 id="执行计划">执行计划</h4><div align="center"><img src="/images/DB执行计划&排查/update索引执行计划.png" alt="update索引执行计划"></div><ul><li><p><strong>select_type：SIMPLE</strong><br> 这是一个简单类型的SQL语句，不含子查询或者UNION。</p></li><li><p><strong>type：index</strong><br> 访问类型，即找到所需数据使用的遍历方式，潜在的方式有：<br> （1）ALL（Full Table Scan）：全表扫描；<br> （2）index：走索引的全表扫描；<br> （3）range：命中where子句的范围索引扫描；<br> （4）ref/eq_ref：非唯一索引/唯一索引单值扫描；<br> （5）const/system：常量扫描；<br> （6）NULL：不用访问表；<br> 上述扫描方式，ALL最慢，逐步变快，NULL最快。</p></li><li><p><strong>possible_keys：NULL</strong><br> 可能在哪个索引找到记录。</p></li><li><p><strong>key：PRIMARY</strong><br> 实际使用索引。</p></li><li><p><strong>ref：NULL</strong><br> 哪些列，或者常量用于查找索引上的值。</p></li><li><p><strong>rows：5</strong><br> 找到所需记录，预估需要读取的行数。</p></li></ul><h4 id="死锁排查">死锁排查</h4><ul><li>有权限的mysql账户执行:<blockquote><p style="color:red;font-size:20px;font-weight:700">show engine innodb status;</p></blockquote></li><li>根据查到的结果 分析LATEST DETECTED DEADLOCK里的内容</li></ul><h3 id="三、ES-提高查询效率">三、ES 提高查询效率</h3><p>学习自: <a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/es-optimizing-query-performance.md" rel="external nofollow noopener noreferrer" target="_blank">ES 在数据量很大的情况下（数十亿级别）如何提高查询效率</a></p><div align="center"><img src="/images/ES/ES方式.png" alt="ES查询原理"></div><ol><li>把尽可能多的索引放在<code>filesystem cache</code>中</li><li>不做复杂查询（Join等），如果有这样的需要，应以设计得更好的document（记录）来实现简单查询（单表）</li><li>使用ES+hbase架构:<br> ES存索引，索引全放在<code>filesystem cache</code>，数据存HBase；通过ES进行条件查询，获取docId，用该docId去查HBase</li><li>禁止深度查询，使用scrollApi或search_after代替</li></ol><h3 id="四、ES存储结构">四、ES存储结构</h3><div align="center"><img src="/images/ES/ES存储结构.png" alt="ES存储结构"></div><blockquote><p style="color:red;font-size:20px;font-weight:700">index -> type -> mapping -> document -> field</p></blockquote><blockquote><p>实例： order~2020-08-02/order/_mapping/记录/字段<br> 翻译： 索引名称/表名/表结构/记录/字段</p></blockquote><h2 id="2019-12-19">2019-12-19</h2><h3 id="Kafka">Kafka</h3><ol><li><strong>基础点</strong></li></ol><blockquote><p>Topic&amp;消费组:<br> <strong>一个Topic的一个Partition只能一个Consumer Group的一个节点消费</strong><br> 一个【Topic】对应多个【Partition】(文件)<br> 消息大小限制:<br> 一条消息 默认最大只能为1000000B(976.56 kB),所以一般规定不允许发送&gt;900k的消息</p></blockquote><ol start="2"><li>版本区别:</li></ol><blockquote><p>0.8版本 (相对历史版本 支持了Replication高可用 )<br> 当时只有Consumer Coordinator<br> coordinator需要依赖于ZK，通过zk监听/consumers/<group>/ids变化 与 brokers/topic的数据变化决定是否要 rebalanced<br> rebalanced后,consumer自己决定自己要消费哪些Partition，然后抢先在/consumers/<group>/owners/<topic>/<partition>下注册（<b style="color:red;font-size:14px">通过这种方式实现一个Topic的一个Partition只能一个Consumer Group的一个节点消费`）</b><br> 同时,各个Consumer Coordinator还需要进行位移的提交</partition></topic></group></group></p><p>弊端: 消费者自己决定消费哪些分区,各个Consumer Coordinator还需要进行位移的提交<br> 并且分区的决定与位移的提交都需要依赖于ZK</p><p>0.8.2版本<br> 0.8.2版本开始同时支持将 offset 存于 Zookeeper 中与将offset 存于专用的Kafka Topic 中,但是需要<b style="color:red;font-size:14px">High Level API</b>的支持，且BUG较多，目前公司用的还是<b style="color:red;font-size:14px">Low Level Api</b></p><p>0.9.x版本<br> 新增Group Coordinator,存在于Broker端<br> 代替了0.8.x版本的zk，每个消费组对应一个，负责每个消费者位移的提交&amp;分区消费的决策</p><p>0.10+<br> 消息结构添加了时间戳，可根据这个时间戳实现延迟队列</p><p>0.11.x版本<br> 新增了对【幂等】、【事务】的支持(依赖于Producer幂等) (exactly-once)</p></blockquote><p>3.High Level和Low Level</p><blockquote><ul><li><s>将仅支持zookeeper维护offset方式的</s> 高级抽象的API称为 <b style="color:red;font-size:14px">Low Level Api</b>,高度抽象,</li><li><s>将支持kafka broker 维护offset方式</s> 抽象低的API的称为 <b style="color:red;font-size:14px">High Level API</b> ，<br> <a href="https://blog.csdn.net/WangQYoho/article/details/78358715" rel="external nofollow noopener noreferrer" target="_blank">High level consumer vs. Low level consumer</a><br> <a href="https://kafka.apache.org/08/documentation.html#simpleconsumerapi" rel="external nofollow noopener noreferrer" target="_blank">官方解释(看最下面的描述)</a></li></ul></blockquote><ol start="4"><li>消息(生产)幂等</li></ol><blockquote><p>每个Topic的每个Partition对每个生产者都维护了一套ID(UUID)<br> 生产者每次发送消息时候,消息体都带上这个ID+1，以此Broker可得知：</p><ul><li>当消息的squence number等于broker维护的squence number + 1，表示消息有序且第一次消费</li><li>当消息的squence number小于或等于broker维护的squence number，表示重复消费额</li><li>当消息的squence number等于broker维护的squence number + n（n &gt; 1），表示存在消息丢失<br> <a href="http://codingcms.cn/2019/10/13/kafka_1/" rel="external nofollow noopener noreferrer" target="_blank">参考1:Kafka Producer 幂等的原理</a><br> <a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960002&amp;idx=1&amp;sn=c0775231bccf002c3178eabe43f1cdcb&amp;chksm=bd2d071e8a5a8e08c3a5287247ea41dee6b2621e6ffafbf909ec1e8a866b7c816eeeea227246&amp;scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">参考2:上半场的幂等性设计</a></li></ul></blockquote><ol start="5"><li>消息的分区选择:</li></ol><blockquote><p>一条消息会根据Key被路由到某一【Partition】（key=0对应分区0）；如果没有指定key，消息会被均匀的分配到所有分区；目前我们封装的方案是，不管有没有Key，都会被随机打乱到每个分区）<br> 每隔 <a href="http://topic.metadata.refresh.interval.ms" rel="external nofollow noopener noreferrer" target="_blank">topic.metadata.refresh.interval.ms</a> 的时间，随机选择一个partition。这个时间窗口内的所有记录发送到这个partition。发送数据出错后也会重新选择一个partition<br> 对key求hash，然后对partition数量求模: <b style="color:red;font-size:14px">Utils.abs(key.hashCode) % numPartitions</b><br> 代码: <b style="color:red;font-size:14px">kafka.producer.async.DefaultEventHandler#handle</b></p></blockquote><ol start="6"><li>Kafka支持的消息发送模式</li></ol><blockquote><p>At most once 消息可能会丢，但绝不会重复传输(例:读到先Commit,再处理)<br> At least one 消息绝不会丢，但可能会重复传输(例:读到先处理,再Commit)<br> Exactly once 每条消息肯定会被传输一次且仅传输一次，很多时候这是用户所想要的 (<b style="color:red;font-size:14px">0.8.2版本还不支持</b>)</p></blockquote><ol start="7"><li><p>高可用<br> kafka默认会重试3次</p></li><li><p>零碎小点</p><ol><li>Kafka实现的是客户端软负载: 让producer决定丢到哪个partition里</li><li>Consumer端仅支持pull模式，这也有利于让Consumer端决定消费速率</li><li>Consumer不能消费太久(如Sleep),因为Kafka会认为程序宕了,分区会重新进行分配,把消息分给其他的Consumer (相关配置项: <a href="http://max.poll.interval.ms" rel="external nofollow noopener noreferrer" target="_blank">max.poll.interval.ms</a>)</li><li>Consumer每次可从Kafka取max.poll.records条数据进行处理</li><li>如果想要消息有序 那么就得保证同个业务key的消息都是发到1个分区里</li></ol></li></ol><h3 id="Redis-Sentinel-Jedis">Redis-Sentinel&amp;Jedis</h3><h4 id="通过Sentinel集群获取Redis主节点原理">通过Sentinel集群获取Redis主节点原理</h4><blockquote><p>SF-Sentinel中配置Redis链(mymaster1,mymaster2,mymaster3)，然后获取每一条链的Master，进行初始化Redis连接池<br> 原生的Sentinel中配置Redis链，然后获取该链的Master，进行初始化Redis连接池</p></blockquote><h4 id="Jedie的Key是如何被存入Redis的某个节点的">Jedie的Key是如何被存入Redis的某个节点的</h4><p><a href="https://my.oschina.net/xinxingegeya/blog/391713" rel="external nofollow noopener noreferrer" target="_blank">参考:Jedis之ShardedJedis一致性哈希分析</a></p><blockquote><p>Jedis初始化时会初始化160个虚拟节点，160个虚拟节点通过Map（Map&lt;ShardInfo<r>, R&gt; resources）映射到实际的Redis-Master节点<br> Jedis在Set key时会对Key分片计算（计算落在160个节点的哪一个），然后再根据虚拟节点与实际节点的映射，把指令发给实际的节点<br> 参考代码：<br> redis.clients.util.Sharded#initialize<br> redis.clients.util.Sharded#getShard(byte[])</r></p></blockquote><h4 id="Redis-Sentinel模式是如何扩容的">Redis-Sentinel模式是如何扩容的</h4><p>空</p><h4 id="Jedis一致性分析">Jedis一致性分析</h4><div align="center"><img src="/images/Redis-Sentinel扩容/Jedis一致性分析.png" alt="Jedis一致性分析"></div><h2 id="2019-11-28">2019-11-28</h2><h3 id="git-rebase-i-HEAD-2">git rebase -i HEAD~2</h3><blockquote><p><code>pick：保留该commit（缩写:p）</code><br> <code>reword：保留该commit，但我需要修改该commit的注释（缩写:r）</code><br> <code>edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）</code><br> <code>squash：将该commit和前一个commit合并（缩写:s）</code><br> <code>fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）</code><br> <code>exec：执行shell命令（缩写:x）</code><br> <code>drop：我要丢弃该commit（缩写:d）</code></p></blockquote><h3 id="Hibernate-基本知识">Hibernate 基本知识</h3><ul><li>inverse属性表示本实体是否拥有主动权<br> <code>inverse只有在非many方才有，也就是many-to-many或者one-to-many的set,List等</code></li></ul><h2 id="2019-11-25">2019-11-25</h2><h3 id="数据库count"><strong>数据库count()</strong></h3><h4 id="官方解释">官方解释</h4><blockquote><p><code>Returns a count of the number of non-NULL values of expr in the rows retrieved by a SELECT statement. The result is a BIGINT value.</code><br> 返回行中 expr 的非 NULL 值的计数</p></blockquote><h4 id="count-和-count-1">count(*) 和 count(1)</h4><blockquote><p>5.7.18以后，两个函数执行计划都是一样的</p><ul><li>如果该表没有任何索引，那么会扫描全表，统计行数</li><li>如果该表只有一个主键索引，没有任何二级索引的情况下，那么通过主键索引来统计行数的</li><li>如果该表有二级索引，则会通过占用空间最小的字段的二级索引进行统计</li></ul></blockquote><h4 id="count-column）">count(column）</h4><blockquote><p>如果字段定义为not null，则按行累加，如果允许有null，则会把值取出来判断一下是不是null，将不是null的值累加返回。</p></blockquote><h4 id="MyISAM-与-InnoDB">MyISAM 与 InnoDB</h4><ul><li>MyISAM会记录每个表的行数，count()时直接返回</li><li>InnoDB会通过扫描全表或索引，得到行数</li><li>在使用count函数中加上where条件时，在两个存储引擎中的效果是一样的，都会扫描全表计算某字段有值项的次数</li></ul><h4 id="DB-select-count速度">DB select count速度</h4><blockquote><p>count(*)=count(1)&gt;count(primary key)&gt;count(column)</p></blockquote><h4 id="参考">参考</h4><p><a href="http://baijiahao.baidu.com/s?id=1645061957944427225&amp;wfr=spider&amp;for=pc" rel="external nofollow noopener noreferrer" target="_blank">MySQL原理：count(*)为什么这么慢，带你重新认识count的方方面面</a></p><h2 id="2019-11-22">2019-11-22</h2><h3 id="垂直-分库分表"><strong>[垂直]分库分表</strong></h3><h4 id="目标"><strong>目标</strong></h4><blockquote><p>通过减少数据量，提升性能</p></blockquote><h4 id="原则"><strong>原则</strong></h4><ul><li>长度较短，访问频率较高的属性尽量放在一个表里，我们将其称为主表<code>(base表)</code></li><li>字段较长，访问频率较低的属性尽量放在一个表里，我们将其称为扩展表<code>(ext表)</code></li><li>经常一起访问的属性，也可以放在一个表里<code>(备选)</code></li></ul><h4 id="大数据量场景注意事项"><strong>大数据量场景注意事项</strong></h4><ul><li><strong>不能用Join</strong><br> <strong>解决方式: 让应用自己拆分成两次查询</strong></li></ul><blockquote><ul><li>base表和ext表不能Join，因为一旦Join了，那么两张表就出现了耦合，这不利于日后拆表到别的数据库实例上</li><li>Join很消耗数据库的性能<code>(分布式场景下,瓶颈往往是数据库)</code></li></ul></blockquote><h4 id="提高性能的原理"><strong>提高性能的原理</strong></h4><ul><li>减少单表的数据量，减少磁盘IO<code>（降低每行记录大小）</code></li><li>更好的利用缓存</li></ul><blockquote><p>因为减少单表数据量还可以充分利用数据库缓存，减少磁盘IO</p></blockquote><h2 id="2019-11-20">2019-11-20</h2><h3 id="数据库基本知识"><strong>数据库基本知识</strong></h3><h4 id="MyISAM与InnoDB索引的区别">MyISAM与InnoDB索引的区别</h4><p>MyISAM:</p><ul><li>MyISAM不存在聚集索引,主键索引与普通索引没区别，叶子节点都是存储的都是<strong>数据的地址</strong></li></ul><p>InnoDB:</p><ul><li>InnoDB必然有[一个]聚集索引<code>（为主键索引,没主键时会用第一个非空普通索引，都没有会生成一个基于行号的聚集索引）</code></li></ul><blockquote><p>select * from t where name=‘lisi’;<br> 会先通过name辅助索引定位到B+树的叶子节点得到id=5，再通过聚集索引定位到行记录</p></blockquote><div align="center"><img src="/images/a-little-progress/InnoDB索引方式.png" alt="InnoDB命中普通索引获取数据方式"></div><p>违反唯一索引场景:<br> MyISAM会出现<strong>一个update语句，部分执行成功，部分执行失败</strong><code>(因为不支持事务)</code></p><h2 id="2019-11-11">2019-11-11</h2><h3 id="Elastic-Job"><strong>Elastic-Job</strong></h3><ol><li>运行规则:<blockquote><p>3台机器的一个集群 ,shardingCount=10 ,分片结果为：1=[0,1,2,9], 2=[3,4,5], 3=[6,7,8] (参考<code>AverageAllocationJobShardingStrategy</code>)<br> 如果本机的数据分片分到了多个分片（即一个JVM进程分到了多个分片），则Elastic-Job会为每一个分片去启动一个线程来执行分片任务</p></blockquote></li><li>线程:<blockquote><p>每个任务对应一个线程池,其默认线程数为: 2*逻辑核心数(参考<code>DefaultExecutorServiceHandler</code>)<br> 线程池配置为: <code>new ThreadPoolExecutor(threadSize, threadSize, 5L, TimeUnit.MINUTES, workQueue, new BasicThreadFactory.Builder().namingPattern(Joiner.on(&quot;-&quot;).join(namingPattern, &quot;%s&quot;)).build());</code> (参考<code>ExecutorServiceObject</code>)</p></blockquote></li><li>问题:<blockquote><p>要注意单机线程数要 大于 单机获取到的分片数 <a href="https://www.jianshu.com/p/0d0e7339c9b0" rel="external nofollow noopener noreferrer" target="_blank">- 参考 《Elastic job 线程模型 源码分析》</a><br> 一个jvm实例 处理多个 job ， 每个job 在该实例上分片数又大于逻辑核心数*2 的数量<br><br> 随着job不断增加 ， 单个job任务执行时间可能会变长 ，有可能超过平时的任务完成超时时间 ，造成任务失败</p><p>举个例子:<br> 如果一台机器 处理器数 2 ， 线程池 就是 4 ， 如果 分片是 5 ， 就是说 一个分片会被排队 ，实际完成时间 &gt;2 个分片 完成时间</p></blockquote></li></ol><h3 id="Elastic-Job其他">Elastic-Job其他</h3><h4 id="1-失效转移">1. 失效转移</h4><blockquote><p><a href="https://www.cnblogs.com/haoxinyue/p/7068115.html" rel="external nofollow noopener noreferrer" target="_blank">- 参考</a></p></blockquote><ol><li><p>【简单的HA】版失效转移 (默认)<br> 在作业节点下线，或者zk的session超时（默认60s）时，会在下一轮任务分片时，把这个该问题节点的分片分给别的正常节点进行作业 （<code>可能会存在作业重复处理的问题</code>）</p></li><li><p>【真正的】'失败’转移 (需要开启)<br> 当<code>failover（默认值为false）</code> 配置为<code>true</code>时，才会启动真正的失效转移；<br> 当<code>failover（默认值为false）</code> 和 <code>monitorExecution（默认值是true）</code>这两个配置都为true时 只有对<code>monitorExecution</code>为<code>true</code>的情况下才可以开启失效转移；<br> 如果任务1在A节点执行【失败】，那么会【转移】给别的存活的节点【竞争】执行这个任务1；</p></li></ol><blockquote><p><a href="https://www.cnblogs.com/kevin-yuan/p/7017795.html" rel="external nofollow noopener noreferrer" target="_blank">- 参考</a><br> <a href="http://elasticjob.io/docs/elastic-job-lite/03-design/lite-design/" rel="external nofollow noopener noreferrer" target="_blank">- 官方参考</a></p></blockquote><h2 id="2019-08-26">2019-08-26</h2><blockquote><p><a href="https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/innodb-record-level-locks.html" rel="external nofollow noopener noreferrer" target="_blank">官方参考</a></p></blockquote><h3 id="MySQL锁">MySQL锁</h3><blockquote><ul><li>InnoDB锁机制是基于索引建立的</li><li>如果SQL语句中匹配不到索引,那么就会升级为表锁</li></ul></blockquote><h4 id="记录锁">记录锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- id 列为主键列或唯一索引列</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> age<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p>通过唯一索引实现的记录锁,只会锁住当前记录(必须为<code>=</code>不然会退化为<code>临键锁</code>)</p></blockquote><h4 id="间隙锁">间隙锁</h4><blockquote><ul><li><strong>间隙锁<font color="red" size="5">只有</font>在事务隔离级别 <font color="red" size="5">RR(可重复读)</font>中才会生效</strong>.</li><li>为非唯一索引组成(如class,age等)</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> student <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">26</span> <span class="keyword">and</span> age<span class="operator">&lt;</span><span class="number">28</span> lock <span class="keyword">in</span> share mode ; <span class="comment">-- 这里以读锁为例</span></span><br></pre></td></tr></table></figure><h5 id="使用间隙锁的条件">使用间隙锁的条件</h5><ul><li>命中普通索引锁定；</li><li>使用多列唯一索引；</li><li>使用唯一索引命中多行记录</li></ul><h5 id="临键锁-Next-key-Locks">临键锁(Next-key Locks)</h5><ul><li><strong>临键锁<font color="red" size="5">只有</font>在事务隔离级别 <font color="red" size="5">RR(可重复读)</font>中才会生效</strong>.</li><li>是记录锁与间隙锁的组合</li><li>可以是<code>唯一索引</code>,也可以是<code>非唯一索引</code>,对其都以间隙锁的形式进行锁定(<code>以唯一索引匹配,并且只匹配到一条数据除外</code>)</li></ul><h6 id="临键锁-Next-key-Locks-例子">临键锁(Next-key Locks) 例子:</h6><table><thead><tr><th>tno<code>(唯一索引)</code></th><th>tname</th><th>tsex</th><th>tbirthday</th><th>prof</th><th>depart</th><th>age<code>(非唯一索引)</code></th></tr></thead><tbody><tr><td>858</td><td>张旭</td><td>1</td><td>1969-03-12</td><td>讲师</td><td>电子工程系</td><td>25</td></tr><tr><td>857</td><td>张旭</td><td>女1</td><td>1969-03-12</td><td>讲师</td><td>电子工程系</td><td>25</td></tr><tr><td>856</td><td>张旭</td><td>男</td><td>1969-03-12</td><td>讲师</td><td>电子工程系</td><td>25</td></tr><tr><td>831</td><td>刘冰</td><td>女</td><td>1977-08-14</td><td>助教</td><td>电子工程系</td><td>29</td></tr><tr><td>825</td><td>王萍</td><td>女</td><td>1972-05-05</td><td>助教</td><td>计算机系</td><td>28</td></tr><tr><td>804</td><td>李诚</td><td>男</td><td>1958-12-02</td><td>副教授</td><td>计算机系</td><td>26</td></tr></tbody></table><blockquote><p>其中有唯一索引的<code>临键</code>为:<br> (-∞,804]<br> (804,825]<br> (825,831]<br> (831,856]<br> (856,857]<br> (857,858]<br> (858,+∞]</p></blockquote><blockquote><p>其中有非唯一索引的<code>临键</code>为:<br> (-∞,25]<br> (25,26]<br> (26,28]<br> (28,29]<br> (29,+∞]</p></blockquote><h6 id="非唯一索引临键锁验证"><strong><code>非唯一索引</code>临键锁验证</strong></h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher <span class="keyword">WHERE</span> age <span class="keyword">between</span> <span class="number">26</span> <span class="keyword">and</span> <span class="number">28</span> lock <span class="keyword">in</span> share mode ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这时候会锁定非唯一索引的<code>临键</code> <code>(25,29]</code><br> 所以我们测试更新age=25–&gt;成功 插入age=27阻塞 更新age=29阻塞 插入age=30成功即可验证</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session2</span></span><br><span class="line"><span class="comment">-- 更新age=25--&gt;成功</span></span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> tsex<span class="operator">=</span><span class="string">&#x27;女1&#x27;</span> <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入age=27阻塞</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `test`.`teacher` ( `tno`, `tname`, `tsex`, `tbirthday`, `prof`, `depart`,`age`) <span class="keyword">values</span> ( <span class="string">&#x27;740&#x27;</span>, <span class="string">&#x27;张旭1&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;1969-03-12 00:00:00&#x27;</span>, <span class="string">&#x27;讲师&#x27;</span>, <span class="string">&#x27;电子工程系&#x27;</span>,<span class="number">27</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新age=29--&gt;阻塞</span></span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> tsex<span class="operator">=</span><span class="string">&#x27;女1&#x27;</span> <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">29</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新age=30--&gt;成功</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `test`.`teacher` ( `tno`, `tname`, `tsex`, `tbirthday`, `prof`, `depart`,`age`) <span class="keyword">values</span> ( <span class="string">&#x27;740&#x27;</span>, <span class="string">&#x27;张旭1&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;1969-03-12 00:00:00&#x27;</span>, <span class="string">&#x27;讲师&#x27;</span>, <span class="string">&#x27;电子工程系&#x27;</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure><h6 id="唯一索引临键锁验证"><strong><code>唯一索引</code>临键锁验证</strong></h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session1</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher <span class="keyword">WHERE</span> tno <span class="keyword">between</span> &quot;831&quot; <span class="keyword">and</span> &quot;856&quot; lock <span class="keyword">in</span> share mode ;</span><br></pre></td></tr></table></figure><blockquote><p>根据上面的sql,我们匹配到<code>唯一索引</code>临键锁为:<code>(825,857]</code><br> 所以我们测试更新tno=825–&gt;成功 更新tno=857阻塞 更新age=858成功即可验证</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更新tno=&quot;825&quot;--&gt;成功</span></span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> tsex<span class="operator">=</span><span class="string">&#x27;女1&#x27;</span> <span class="keyword">WHERE</span> tno<span class="operator">=</span>&quot;825&quot;;</span><br><span class="line"><span class="comment">-- 更新tno=&quot;857&quot;--&gt;阻塞</span></span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> tsex<span class="operator">=</span><span class="string">&#x27;女1&#x27;</span> <span class="keyword">WHERE</span> tno<span class="operator">=</span>&quot;857&quot;;</span><br><span class="line"><span class="comment">-- 更新tno=&quot;858&quot;--&gt;成功</span></span><br><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> tsex<span class="operator">=</span><span class="string">&#x27;女1&#x27;</span> <span class="keyword">WHERE</span> tno<span class="operator">=</span>&quot;858&quot;;</span><br></pre></td></tr></table></figure><h2 id="2019-08-22">2019-08-22</h2><h3 id="Spring事务-AOP增强">Spring事务/AOP增强</h3><ul><li><code>@EnableAspectJAutoProxy(exposeProxy = true)</code></li></ul><ol><li>进入代理时,通过<code>AopContext.serCurrentProxy(proxy)</code>把当前代理设置到ThreadLocal中</li><li>后续在线程销毁(请求结束)前调用代理内部之间的调用就可以通过<code>((AService)AopContext.currentProxy()).b()</code>进行调用了</li><li>PS. 性能影响不大 不过实际上代理内部之间还需要AOP增强的场景不多,一般没必要用</li></ol><h3 id="Spring-LTW实现的静态织入（应该不能叫做代理）">Spring LTW实现的静态织入<code>（应该不能叫做代理）</code></h3><blockquote><ul><li>需要添加配置：</li></ul><ol><li>代码添加: <code>@EnableLoadTimeWeaving(aspectjWeaving=ENABLED)</code>或<code>&lt;context:load-time-weaver aspectj-weaving=&quot;enable&quot; /&gt;</code></li><li>添加JVM参数<code>-javaagent:类加载器代理路径</code></li></ol></blockquote><ol><li><p><code>LTW(LoadTime Weaving)</code><br> 加载时织入。在通过JVM加载类时候会先调用<code>ClassTransformer</code>的<code>transform()</code>进行字节码替换后才会进行加载。</p></li><li><p><code>静态AOP</code><br> 通过<code>LTW</code>可以实现<code>静态AOP</code>增强，加载到的类就是已经增强后的代码。这样我们调用方法的时候,直接就是调用了增强后的方法,比起动态代理的调用,更加地高效。</p></li></ol><p>上述流程大致如下所示:</p><pre class="mermaid">graph TD
A[Target]
B[增强后的字节码]
C[加载后的代码]
D[注入后的Bean]
E[调用方]
A--ClassTransformer的transform方法进行字节码植入-->B
B--JVM加载-->C
C--Spring使用,创建/注入Bean-->D
E--方法调用-->D</pre><h2 id="2019-08-01">2019-08-01</h2><h3 id="Spring事务">Spring事务</h3><blockquote><p>对于this.b()这些类实例的内部调用，b()实际上是无事务的<br> 但是可以用<code>((AService)AopContext.currentProxy()).b()</code> 结合<code>@EnableAspectJAutoProxy(exposeProxy = true)</code> 这样b()就包裹在事务里了</p></blockquote><h2 id="2019-7-20">2019-7-20</h2><h3 id="seata">seata</h3><ul><li>seata需要管理所有的数据库操作，不然不能通过前镜像进行回滚</li></ul><h2 id="2019-7-17">2019-7-17</h2><h3 id="Spring事务-Cglib">Spring事务/Cglib</h3><ol><li>final,static,private修饰符无法被增强</li></ol><blockquote><p>由于使用final,static,private修饰符的方法都不能被子类覆盖，相应的，这些方法将不能被实施的AOP增强</p></blockquote><ol start="2"><li>增强应该作用在实现类中</li></ol><blockquote><p>@Transactional 注解可以作用于接口、接口方法、类以及类方法上，<strong><font color="red" size="5">但是 Spring 建议不要在接口或者接口方法上使用该注解</font></strong>，<font color="red">因为这只有在使用基于接口的代理时它才会生效</font>。</p></blockquote><h2 id="2019-5-20">2019-5-20</h2><h3 id="【GC日志】GC耗时解析">【GC日志】GC耗时解析</h3><blockquote><p>【Time: user=0.71 sys=0.01 real=0.02 secs】</p><ol><li>user表示：本次GC过程中【所有线程】在用户态消耗的时间总和</li><li>sys表示： 本次GC过程中 【所有线程】在内核态所消耗的时间总和</li><li>real表示：本次GC过程中，实际GC消耗的时间</li></ol></blockquote><h2 id="2019-5-1">2019-5-1</h2><h3 id="数据库MVCC">数据库MVCC</h3><blockquote><ul><li>MVCC：多版本并发控制(Multi-Version Concurrency Control)</li><li>优势：查询速度快，并发环境尤是。<strong><font color="red">对于大多数读操作，我们只需要通过MVCC进行简单的查询操作，而不需要获取任何一个<code>锁</code>。</font></strong></li><li>劣势：需要多存储数据。<strong><font color="blue">对每一条记录都需要存储所有版本的数据</font></strong></li><li><strong><font color="red">MVCC只工作在REPEATABLE READ和READ COMMITED隔离级别下</font></strong></li><li>READ UNCOMMITED不是MVCC兼容：因为这个模式只能读取到最新的数据</li><li>SERIABLABLE也不与MVCC兼容：因为每个读操作都需要为读到的数据上锁</li></ul></blockquote><h2 id="事务"><img src="/images/a-little-progress/db-transactional-note.png" alt="事务"></h2><h4 id="MVVC机制：">MVVC机制：</h4><blockquote><ul><li>以下摘自<a href="https://mp.weixin.qq.com/s/vRf5p9c9_4GrmFLaqEZI6w" rel="external nofollow noopener noreferrer" target="_blank">《五分钟搞清楚 MVCC 机制》</a></li></ul></blockquote><ol><li><p>每一条数据库表记录,都隐藏2个字段</p><ul><li>数据行的版本号 （DB_TRX_ID）</li><li>删除版本号 (DB_ROLL_PT)</li></ul></li><li><p>执行insert语句插入的时候,会把当前的事务ID写到该记录的数据行的版本号 （DB_TRX_ID）中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;-- 获取到全局事务ID 假设为2</span><br><span class="line">insert into `test_zq` (`id`, `test_id`) values(&#x27;5&#x27;,&#x27;68&#x27;);</span><br><span class="line">commit;-- 提交事务</span><br></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>test_id</th><th>DB_TRX_ID</th><th>DB_ROLL_PT</th></tr></thead><tbody><tr><td>5</td><td>68</td><td>2</td><td>NULL</td></tr><tr><td>6</td><td>78</td><td>1</td><td>3</td></tr></tbody></table></li><li><p>修改数据库记录的时候</p><ol><li>更新原记录的删除版本号 (DB_ROLL_PT)为当前事务ID</li><li>插入一行新的更新后的记录,且它的数据行的版本号 （DB_TRX_ID）为当前事务ID</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;-- 获取全局系统事务ID 假设为 10</span><br><span class="line">update test_zq set test_id = 22 where id = 5;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>test_id</th><th>DB_TRX_ID</th><th>DB_ROLL_PT</th></tr></thead><tbody><tr><td>5</td><td>68</td><td>2</td><td>10</td></tr><tr><td>6</td><td>78</td><td>1</td><td>3</td></tr><tr><td>5</td><td>22</td><td>10</td><td>NULL</td></tr></tbody></table></li><li><p>查询的时候需要根据<code>数据行的版本号 （DB_TRX_ID）</code> 和 <code>删除版本号 (DB_ROLL_PT)</code> 二者进行数据数据筛选，需要同时满足以下规则：</p><ol><li><code>数据行的版本号 （DB_TRX_ID）</code> &lt;= 当前事务</li><li><code>删除版本号 (DB_ROLL_PT)</code> &gt; 当前事务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;-- 假设拿到的系统事务ID为 10</span><br><span class="line">select * from test_zq;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>test_id</th><th>DB_TRX_ID</th><th>DB_ROLL_PT</th></tr></thead><tbody><tr><td>6</td><td>22</td><td>10</td><td>NULL</td></tr></tbody></table></li></ol><h2 id="2019-04-24">2019-04-24</h2><h3 id="Spring的Lifecycle-SpringAppilication生命周期">Spring的Lifecycle (SpringAppilication生命周期)</h3><blockquote><p>Spring会拿到所有Lifecycle实现类，然后委托DefaultLifecycleProcessor进行逐个处理</p></blockquote><ul><li>Lifecycle 可以在SpringAppilication在初始化后执行start()方法,Spring停止的时候调用stop()方法</li><li>但是单单实现该类不能实现SpringAppilication在启动后,停止时调用Lifecycle对应的方法</li><li>这时候我们应该需要使用SmartLifecycle（Lifecycle的子类）,重写isAutoStartup()返回true，才能产生理想效果</li></ul><h2 id="2019-04-23">2019-04-23</h2><h3 id="关于测试类的规范">关于测试类的规范</h3><ol><li>单元测试应该是不依赖于别的单元测试的</li><li>所有单元测试应该都得回滚，如果存在异步处理的情况，应尽可能把主线程与fork线程拆成2个测试类方法进行测试</li><li>每个测试类／测试方法应写上对应的名称@DisplayName</li><li>每个接口，都必须写一个正向测试方法</li><li>关于测试类的类名：测试类与被测试的类的路径需要一致，名字也需要对应，如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.fpx.wms.service.impl.InstockServiceImpl</span><br><span class="line">↓对应↓</span><br><span class="line">com.fpx.wms.service.impl.InstockServiceImplTest</span><br></pre></td></tr></table></figure><ol start="6"><li>关于测试类的方法名： 方法名尽可能为成功的条件如shouldSuccessAfterPay()，而方法具体用来测试哪个场景的，我们已经使用了@ DisplayName来描述，无须担心</li><li>对于结果，需要适应assert断言输出与结</li></ol><h2 id="2019-04-22">2019-04-22</h2><h3 id="Spring-Lookup">Spring @Lookup</h3><h4 id="作用">作用</h4><blockquote><p>在单例A里 可能依赖到原型类型B,这时候如果用普通的Autowrite不能拿到原型的B，这时候就需要使用@Lockup了</p></blockquote><h4 id="使用参考">使用参考</h4><ul><li><a href="https://wangxiang5050.github.io/reading/2018/05/29/spring-lookup/" rel="external nofollow noopener noreferrer" target="_blank">参考地址</a></li><li><a href="https://www.baeldung.com/spring-lookup" rel="external nofollow noopener noreferrer" target="_blank">官网地址参考地址</a></li></ul><h2 id="2019-04-21">2019-04-21</h2><h3 id="架构设计三大原则">架构设计三大原则</h3><ul><li>合适原则</li><li>简单原则</li><li>演化原则</li></ul><blockquote><p>即，合适优于先进，简单优于复杂，演化优于一步到位<br> →能不分，尽可能不分</p></blockquote><h2 id="2019-03-20">2019-03-20</h2><h3 id="策略模式-vs-命令模式">策略模式 vs 命令模式</h3><h4 id="1-策略模式">1. 策略模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">策略模式针对一个命令,多种实现方式</span><br></pre></td></tr></table></figure><h4 id="2-命令模式">2. 命令模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令模式针对多个命令,每种命令都有各自的实现</span><br></pre></td></tr></table></figure><h4 id="3-总结">3. 总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令模式等于菜单中的复制，移动，压缩等，而策略模式是其中一个菜单的例如复制到不同算法实现。</span><br></pre></td></tr></table></figure><h2 id="2019-03-15">2019-03-15</h2><h3 id="策略模式-vs-代理模式">策略模式 vs 代理模式</h3><h4 id="1-策略模式-v2">1. 策略模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要调用方告知具体的策略</span><br></pre></td></tr></table></figure><h4 id="2-代理模式">2. 代理模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要调用方告知使用哪个[代理类]</span><br><span class="line">具体的【被代理类】由【代理类】生成，客户端不知道具体被代理的是谁</span><br></pre></td></tr></table></figure><h4 id="2-1-动态代理">2.1 动态代理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要调用方告知[被代理类]及其接口</span><br></pre></td></tr></table></figure><h4 id="3-One-More-Thing">3.One More Thing</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">以上模式都需要客户端告知具体的[策略]/[代理]/[被代理者]</span><br><span class="line">为了使实现其与调用方进行隔离,可以使用[**工厂模式**]进行隔离</span><br></pre></td></tr></table></figure><h2 id="2019-03-12">2019-03-12</h2><h3 id="Spring循环依赖">Spring循环依赖</h3><p><code>场景现有3个类相互依赖，依赖关系分别为：</code></p><pre class="mermaid">graph LR
A-->B
B-->C
C-->A</pre><p><code>场景细分为3种</code></p><ol><li>构造注入参数循环依赖(报错)<br> 报错</li></ol><blockquote><p>根据Spring初始化方式,Spring容器会按照顺序创建&quot;无属性&quot;的A放到<font size="1" color="red">“当前创建Bean池”</font>中，同理再B、C、A，但是在再次创建A的时候发现<font size="1" color="red">“当前创建Bean池”</font>已经存在A了，那么这时候会报错循环依赖</p></blockquote><ol start="2"><li>Setter注入的循环依赖(<code>单例</code>)</li></ol><blockquote><p>没毛病，在set的时候对象ABC都已经实例化放在Spring缓存了好了</p></blockquote><ol start="3"><li>Setter注入的循环依赖(<code>prototype</code>)<br> 报错</li></ol><blockquote><p><code>prototype</code>修饰的bean不会被Spring缓存,都是使用的时候当场创建的</p></blockquote><h3 id="Spring注入方式选择">Spring注入方式选择</h3><p>结合上面的循环依赖问题，Setter出现问题的概率会低一些 推荐使用Setter注入</p><ol><li>构造注入</li><li>Setter注入</li><li>接口注入(没用过)</li></ol><h2 id="2019-03-11">2019-03-11</h2><h3 id="一、集合操作">一、集合操作</h3><h4 id="遍历">遍历</h4><ol><li>Enumeration(JDK1.0)<ul><li>只提供读集合相关功能，因为没有fail-fast，速度较快一点</li></ul></li><li>Iterator(<font color="red">推荐</font>)<ul><li>除了读功能，还有删除集合元素的能力，并且支持fail-fast（防止多线程同时对集合修改的一种机制）</li></ul></li></ol><h4 id="修改">修改</h4><p><font color="grean">正例：</font><br><br> 以List为例子,先得获取他的Iterator,通过iterator来进行修改操作<br><br><br> <font color="red">反例：</font><br><br> 使用增强型foreach进行add/remove操作：</p><blockquote><p>因为增强型foreach实际上是使用iterator实现的java语法糖:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;test12&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;test13&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;test14&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (String userName : userNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userName.equals(<span class="string">&quot;test12&quot;</span>)) &#123;</span><br><span class="line">        userNames.remove(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译后</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.add(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.add(<span class="string">&quot;test12&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.add(<span class="string">&quot;test13&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.add(<span class="string">&quot;test14&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">var1</span> <span class="operator">=</span> userNames.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> (String)var1.next();</span><br><span class="line">    <span class="keyword">if</span> (userName.equals(<span class="string">&quot;test12&quot;</span>)) &#123;</span><br><span class="line">        userNames.remove(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">所以实际上for (String userName : userNames) 这里每次都会去调用itertor.next()</span><br><span class="line">如果你在迭代期间,操作了list.add()和list.remove()等不通过Iterator的操作</span><br><span class="line">next()里会去调用checkForComodification()方法</span><br><span class="line">然后发现modCount != expectedModCount 抛出异常</span><br><span class="line"></span><br><span class="line">因为list.add()和list.remove()等不通过Iterator的操作,是不会修改expectedModCount的</span><br></pre></td></tr></table></figure><h4 id="其它">其它</h4><ul><li><code>fail-fast：</code></li></ul><blockquote><p>防止多线程同时对集合修改的一种机制<br></p></blockquote><ul><li><code>modCount：</code></li></ul><blockquote><p>****List**中的一个成员变量。它表示该集合实际被修改的次数</p></blockquote><ul><li><code>expectedModCount：</code></li></ul><blockquote><p>是 ****List**中的一个内部类——<font size="3" color="red">Itr中的成员变量</font></p></blockquote><h3 id="二、Hystrix">二、Hystrix</h3><ol><li>Feign-starter包含Hystrix以及ribbon(只用他的均衡负载 http请求还是用feign自己的)</li><li>一个@FeignClient对应一个线程池或信号量</li><li>隔离<ul><li>线程池隔离</li></ul><blockquote><p><strong>tomcat的请求线程会交给线程池的线程处理</strong><br> 超过线程池会排队或者降级，一个线程池对应的服务挂了，不会影响别的线程池的服务</p></blockquote><ul><li>信号量隔离</li></ul><blockquote><p><strong>只作为开关</strong><br> 并发数超过X服务的信号量,多出来的Tomcat请求将会被拒绝</p></blockquote></li></ol><hr><h2 id="2019-03-09">2019-03-09</h2><p><img src="/images/a-little-progress/data-struct.png" alt="img.png"></p><h2 id="2019-03-05">2019-03-05</h2><h3 id="一、StringBuilder在高性能场景下的正确用法">一、StringBuilder在高性能场景下的正确用法</h3><p><a href="http://nathanchen.github.io/14596982516208.html" rel="external nofollow noopener noreferrer" target="_blank">StringBuilder在高性能场景下的正确用法(文中代码打错了一些字…)</a></p><ul><li>正确写法应该是这样↓<br> <a href="/file/stringbuilderdemo/StringBuilderUtil.java">StringBuilderUtil.java</a></li></ul><h2 id="2019-03-01">2019-03-01</h2><h3 id="一、分布式锁">一、分布式锁</h3><blockquote><p>从需求上说，分布式锁要求是不一样的：</p><ol><li>如果是用于聊天等社交场景,那么可以使用AP的分布式锁:Redis</li><li>如果是用于交易等不允许极端情况下获取锁不一致的，那么AP的Redis锁是不能接受的，这时候一定得用CP的分布式锁,如:etcd Zookeeper这一类</li></ol></blockquote><h2 id="2019-02-22">2019-02-22</h2><h3 id="一、ThreadLocal">一、ThreadLocal</h3><p><img src="/images/%E5%B9%B6%E5%8F%91/ThreadLocal.png" alt="ThreadLocal数据结构"><br> <img src="/images/a-little-progress/ThreadLocal2.png" alt="ThreadLocal引用关系.png"></p><ol><li><p><strong><font color="red" size="4">每个线程都有一个ThreadLocalMap</font></strong>,ThreadLocalMap以Entry的形式保存着各个线程自己的数据</p></li><li><p>Entry为一个WeakReference,以你new的ThreadLocal为Key</p></li><li><p>基于2.当你new的ThreadLocal没被外部强引用时,线程该Thread下对应该ThreadLocal的Entry会在下次GC被回收</p></li><li><p>当一条线程创建了多个ThreadLocal，多个ThreadLocal放入ThreadLocalMap 会极大地增加冲突概率</p></li><li><p>ThreadLocalMap对冲突的处理方式与普通HashMap的链表处理不一样，而是以原来的位置+1，一直寻找到没有冲突的地方存入</p></li><li><p>ThreadLocal在ThreadLocalMap中是以一个弱引用身份被Entry中的Key引用的</p></li><li><p>ThreadLocal.remove(),移除ThreadLocalMap与Entry的关系，释放内存</p></li></ol><h2 id="2019-02-17">2019-02-17</h2><h3 id="一、常量池">一、常量池</h3><p>常量池包含:</p><ol><li>class常量池 存在于class文件中</li><li>运行时常量池 存在于方法区中 一个类对应一个运行时常量池</li><li>字符串常量池 全局唯一 JDK6存在于方法区(独立于运行时常量池) JDK6以后存在于堆中</li></ol><h3 id="二、字符串加载到字符串常量池的2种方式">二、字符串加载到字符串常量池的2种方式</h3><pre class="mermaid">graph LR
A[编译后的class文件中的class常量池]
B[运行时常量池*N]
C[字符串常量池]
D[Java代码运行]
A-->B
D-->B
B-->C</pre><h2 id="2019-01-28">2019-01-28</h2><h3 id="Mybatis">Mybatis</h3><h4 id="一级缓存">一级缓存</h4><blockquote><p>(范围为一个SqlSession)<br> 有Session/STATEMENT级别:</p></blockquote><ul><li>默认是SESSION 级别，即在一个MyBatis会<br> 话中执行的所有语句，都会共享这一个缓存。</li><li>一种是STATEMENT 级别，可以理解为缓存只对当前执行的<br> 这一个Statement 有效</li></ul><h4 id="二级缓存">二级缓存</h4><blockquote><p>基于mapper<br> 二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享</p></blockquote><ul><li>补充: 缓存为本地缓存, 在集群部署的系统里开启后,会导致A1查询与A2查询结果不一致的问题 看情况开启,一般为关闭;或者使用Redis等工具使用统一的第三方缓存</li></ul><h2 id="2018-11-06">2018-11-06</h2><h3 id="一、-分布式事物要看场景的">一、 分布式事物要看场景的</h3><p>举个例子:</p><blockquote><ol><li>流量充值涉及到订单支付，金钱交易严格用tcc;</li><li>订单支付完后要给用户增加积分，这个必要成功，用最终消息一致性方案;</li><li>订单支付完后还要给用户发送一条短信，短信一般是跟电信运营商的第三方接口对接，有可能成功有可能失败，用最大努力通知方案</li></ol></blockquote><span id="more"></span><hr><h2 id="2018-11-06-v2">2018-11-06</h2><h3 id="一、JVM逃逸分析与TLAB-Thread-Local-Allocation-Buffer">一、JVM逃逸分析与TLAB(Thread Local Allocation Buffer)</h3><blockquote><p>启动逃逸分析后,会分析没有逃逸的对象,把没有逃逸的对象分配在线程私有的栈里,性能提高5倍<br> TLAB(默认开启)存在于新生代,默认占其1%,为线程私有;因为线程私有,没有锁开销(对象分配的时候不需要锁住整个堆),效率高;</p></blockquote><blockquote><p>创建对象时内存分配流程:</p><ol><li>逃逸分析,确定分配在哪,如果是分配在堆则2</li><li>尽量分配在当前线程的TLAB,不够就去再申请一个TLAB,还不够则3</li><li>加锁Eden区,在Eden申请内存,不够则4,</li><li>执行Young GC</li><li>Young GC后,如果还不够,放入老年代</li></ol></blockquote><blockquote><p>对象分配流程写的不错<br> 参考:<a href="https://blog.csdn.net/yangzl2008/article/details/43202969" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/yangzl2008/article/details/43202969</a></p></blockquote><hr><h2 id="2018-10-19">2018-10-19</h2><h3 id="一、Feign-Consul-获取可用服务IP">一、Feign Consul 获取可用服务IP</h3><ul><li>HealthConsulClient.getHealthServices获取可用IP</li></ul><blockquote><p>通过<a href="http://consul.uat.i4px.com:8500/v1/health/service/pds-pos-outer?token=" rel="external nofollow noopener noreferrer" target="_blank">http://consul.uat.i4px.com:8500/v1/health/service/pds-pos-outer?token=</a><br> 最终会在ConsulServerUtils.findHost()得到服务所对应的可用IP<br> IP获取逻辑是:</p><ol><li>获取Service.Address字段作为可用IP</li><li>取不到就取Node.Address</li></ol></blockquote><h3 id="二、Consul">二、Consul</h3><blockquote><p>1.服务注销/删除<br> <a href="http://consul.uat.i4px.com:8500/v1/agent/service/deregister/fpx-prs-service-10-104-5-15-8002" rel="external nofollow noopener noreferrer" target="_blank">http://consul.uat.i4px.com:8500/v1/agent/service/deregister/fpx-prs-service-10-104-5-15-8002</a><br> 2.查看可用服务<br> <a href="http://consul.uat.i4px.com:8500/v1/health/service/wims?passing=true" rel="external nofollow noopener noreferrer" target="_blank">http://consul.uat.i4px.com:8500/v1/health/service/wims?passing=true</a></p></blockquote><hr><h2 id="2018-10-18">2018-10-18</h2><h3 id="一、多服务的【事务】阻塞（跨机器）">一、多服务的【事务】阻塞（跨机器）</h3><ul><li>数据库锁分为读锁、写锁，读读共享，写写互斥，读写互斥</li><li>程序A正在开启事务,操作(包括CRUD) 数据库记录A时,A会被行级锁（读/写锁）;</li><li>其它程序若要对进行互斥锁操作,需要阻塞到该锁被释放(程序A提交事务)，</li></ul><hr><h2 id="2018-09-29">2018-09-29</h2><h3 id="一、接口返回的JSON数据-快速转换为实际数据">一、接口返回的JSON数据,快速转换为实际数据</h3><blockquote><p>ObjectMapper mapper = new ObjectMapper();<br> SimsPudo simsPudo = mapper.convertValue(responseMessage.getData(), SimsPudo.class);</p></blockquote><hr><h2 id="2018-09-29-v2">2018-09-29</h2><h3 id="一、-XX-PrintFlagsFinal">一、-XX:+PrintFlagsFinal</h3><blockquote><p>:=意味着值是被修改的, =表示默认值</p></blockquote><hr><h2 id="2018-09-29-v3">2018-09-29</h2><h3 id="一、Feign重试">一、Feign重试</h3><ul><li>默认只会对connect timeout进行重试</li><li>OKToRetryOnAllOperations=true</li></ul><blockquote><ol><li>会对connect timeout和socket read timeout都进行重试,对socket read timeout会引起后端重复处理请求问题(需要做幂等)</li><li>Feign对于&gt;400的后端报错是不会重试的</li><li>设置了OKToRetryOnAllOperations=true所有后端需要幂等<br> OKToRetryOnAllOperations=false的前端需要做对应的超时异常处理,如:<br> 　　i.写代码自动重试<br> 　　ii.直接返回前台成功</li></ol></blockquote><h3 id="二、超时时间">二、超时时间</h3><ol><li>(socket)connect timeout 连接超时</li><li>(socket)read timeout 读超时</li></ol><blockquote><p>对read timout,请求已经到达后端处理,但是没在指定时间内返回</p></blockquote><h3 id="三、Http状态码分类">三、Http状态码分类</h3><ol><li>1XX:正在处理</li><li>2XX:请求处理成功</li><li>3XX:请求需要重定向</li><li>4XX:服务器无法处理请求(U Fuck Off)</li><li>5XX:服务器处理请求出错(I Fuck Off)</li></ol><h3 id="四、String">四、String</h3><blockquote><ol><li>“ABC”:<br> 是显示声明的 以&quot;ABC&quot;形式存在于常量池中(常量池也在堆里)</li><li>new String(“ABC”):<br> 以对象形式存在于堆中</li><li>str.intern(),字符串(或引用)是否存在于常量池,不存在就把该引用存在常量池</li><li>“ABC”.intern() 没意思,本来就是放在常量池的东西,再调intern没用</li></ol></blockquote><h3 id="五、-Transaction">五、@Transaction</h3><blockquote><ol><li>@Transactional方法会覆盖类上的配置</li><li>调用被注入的代理类才能有效地激活@Transaction的效果</li></ol></blockquote><hr><h2 id="2018-09-28">2018-09-28</h2><h3 id="一、JVM参数配置">一、JVM参数配置</h3><blockquote><p>-XX:+PrintCommandLineFlags<br> 打印改动过的JVM参数<br> -XX:+PrintFlagsFinal打印最终在用的参数<br> -XX:+UnlockExperimentalVMOptions<br> -XX:+UnlockDiagnosticVMOptions<br> 显示隐藏参数</p></blockquote><h3 id="二、Feign前后端全局异常处理">二、Feign前后端全局异常处理</h3><blockquote><ol><li>后端【业务代码直接抛异常】</li><li>后端全局异常捕获时【返回带异常信息的ResponseMsg】(一般不含堆栈信息),同时返回状态码设置为500(也可以404,因为Feign默认后端报错就是返回404)</li><li>前端(调用者)ErrorDecode时,解析该[ResponseMsg的异常信息],重新throw对应的异常就能保证前后端异常一致了</li></ol></blockquote><ul><li>[x] 对于需要进入fallback的调用</li></ul><blockquote><p>同上处理,但是按需可能需要使用FallbackFactory获取后端返回的异常信息进一步处理 如打印日志等</p></blockquote><ul><li>[ ] 问题:可能导致前端(调用方)不能切换实例重试</li><li>[ ] 加入Decode404=true后,404错误不会进入ErrorDecode和Fallback</li></ul><hr><h2 id="2018-09-17">2018-09-17</h2><h3 id="一、正确的kill进程">一、正确的kill进程</h3><blockquote><p>先kill -15(安全关闭 回收资源)<br> 不行再kill -9(强制关闭)</p></blockquote><h2 id="2018-09-16">2018-09-16</h2><h3 id="一、JDK8-移除了Perm">一、JDK8+移除了Perm</h3><blockquote><p>jdk8移除了Perm<br> 其方法区及常量池等数据,全部移到了元数据区(Metaspace)中</p></blockquote><h3 id="二、String-intern">二、String.intern</h3><blockquote><p>JDK7及以后版本,是复制其字符串引用到常量池中<br> 实际数据还是存在于堆中</p></blockquote><h3 id="二、-XX-MetaspaceSize">二、-XX:MetaspaceSize</h3><blockquote><p>-XX:MetaspaceSize=200m不是初始元空间大小,而是达到了200m后才会对该区域进行GC</p></blockquote><hr><h2 id="2018-09-06">2018-09-06</h2><h3 id="一、获取全局唯一ID">一、获取全局唯一ID</h3><blockquote><ol><li>redis: 服务器时间戳+redis全局自增id=&gt;UUID<br> 简单、快捷</li><li>zk:同上<br> 比较慢</li><li>通过数据库<br> 慢、并发低</li><li>twitter的雪花算法: 通过时间戳+机器ID=&gt;UUID<br> 优势:速度快、无需依赖中间件、全局唯一</li></ol><p>实现参考：<a href="https://github.com/souyunku/SnowFlake" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/souyunku/SnowFlake</a></p></blockquote><hr><h2 id="2018-09-05">2018-09-05</h2><h3 id="一、SQL的强制索引">一、SQL的强制索引</h3><blockquote><p>select * from parcel <strong>FORCE INDEX(uniq_fpx_tracking_no_1)</strong> where fpx_tracking_no not in (‘901000486441’,‘901000497454’) ;</p></blockquote><h3 id="二、接口幂等理解">二、接口幂等理解</h3><ol><li><p>分布式锁实现幂等的方式</p><ol><li><ul><li>查询缓存结果,存在就返回</li></ul></li><li><ul><li>不存在,获取分布式锁(阻塞等待)</li></ul></li><li><ul><li>再尝试第一步(其实就是双重校验)</li></ul></li><li><ul><li>不存在,开始执行业务逻辑,并且缓存结果</li></ul></li><li><ul><li>释放锁</li></ul></li></ol></li><li><p>分布式锁实现的幂等,不完全可靠,因为缓存会过期</p><ol><li>要保证其绝对可靠,还是得使用select+insert、唯一索引等方式</li></ol></li></ol><h3 id="三、IO多路复用模型">三、IO多路复用模型</h3><p><a href="https://mp.weixin.qq.com/s/xmSn9Xz6MiFb2s_0J7iXwQ" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s/xmSn9Xz6MiFb2s_0J7iXwQ</a></p><blockquote><ol><li>单Reactor单线程(Redis)</li><li>单Reactor多线程</li><li>多Reactor多线程(包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持)</li></ol></blockquote><blockquote><ul><li>单 Reactor 单线程，接待员、侍应生、后厨是同一个人，全程为顾客服务</li><li>单 Reactor 多线程，1个接待员，多个后厨</li><li>主从 Reactor 多线程，1个接待员，多个侍应生，多个后厨</li></ul></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="https://heyfl.gitee.io">花火</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a href="https://heyfl.gitee.io/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day-Basic-Technology.html">https://heyfl.gitee.io/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day-Basic-Technology.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://heyfl.gitee.io" target="_blank">花火笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%AF%8F%E5%A4%A9%E8%BF%9B%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9/">每天进步一点点</a><a class="post-meta__tags" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">知识点整理</a></div><div class="post-share"><div class="social-share" data-image="/img/img.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day-English.html" title="每天进步一点点 - English"><img class="cover" src="/images/make-a-little-progress-every-day/%E6%AF%8F%E5%A4%A9%E8%BF%9B%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%20-%20English.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">每天进步一点点 - English</div></div><div class="info-2"><div class="info-item-1"> [原创]这篇只是做点个人英语学习的记录，请批判接受，有误请指正。转载请注明出处: https://heyfl.gitee.io/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day-English.html 2025-12-11 Vocabulary Sentence - conversation Just updating is enough. (只要更新就够了) I call handle it all by myself, expect business matters. (我自己处理所有事情，除了商务事务) I am swamped. (我忙得不可开交) Sentence - email I am here to assist you with anything you need. (我在这里协助你处理任何你需要的事情) I am writing to inform you that… (我写信是为了通知你…) Please let me know if you have any qu...</div></div></div></a><a class="pagination-related" href="/idea/performance-optimization-core-ideas.html" title="性能优化核心思想"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">性能优化核心思想</div></div><div class="info-2"><div class="info-item-1"> [原创]个人理解，请批判接受，有误请指正。转载请注明出处: https://heyfl.gitee.io/idea/performance-optimization-core-ideas.html 性能优化核心思想 1. 网络传输上 选择合适的传输协议，如Http-&gt;dubbo，以二进制传输+长连接请求 开启序列化、压缩等，对于大数据量的传输可能有特别大的提升 对于重复请求同一个url的连接池，使用长连接 对于不需立即响应的，使用异步请求 对即时聊天等双向实时性要求高的，使用webSocket全双工等 2. JVM 选择合适的GC算法，如CMS、Parallel、G1等 CMS（JDK&lt;1.9）关注低停顿，Parallel关注吞吐量，G1通过较精准把控停顿时间,也可以说是关注整体吞吐量和延迟吧，当前市场上主要用于大内存场景 选择合适的GC参数，如堆内存大小、新生代大小、老年代大小、GC线程数、GC触发条件等 这个属于调优方面的了，需要结合jstat命令与gc detail或者监控工具等配置； 3. 系统架构上的优化(核心) 合理模块依赖关系，...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day-English.html" title="每天进步一点点 - English"><img class="cover" src="/images/make-a-little-progress-every-day/%E6%AF%8F%E5%A4%A9%E8%BF%9B%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%20-%20English.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2099-12-05</div><div class="info-item-2">每天进步一点点 - English</div></div><div class="info-2"><div class="info-item-1"> [原创]这篇只是做点个人英语学习的记录，请批判接受，有误请指正。转载请注明出处: https://heyfl.gitee.io/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day-English.html 2025-12-11 Vocabulary Sentence - conversation Just updating is enough. (只要更新就够了) I call handle it all by myself, expect business matters. (我自己处理所有事情，除了商务事务) I am swamped. (我忙得不可开交) Sentence - email I am here to assist you with anything you need. (我在这里协助你处理任何你需要的事情) I am writing to inform you that… (我写信是为了通知你…) Please let me know if you have any qu...</div></div></div></a><a class="pagination-related" href="/MQ/mq-rabbitmq.html" title="消息中间件-Rabbitmq"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-09</div><div class="info-item-2">消息中间件-Rabbitmq</div></div><div class="info-2"><div class="info-item-1"> [原创]个人理解，请批判接受，有误请指正。转载请注明出处: https://heyfl.gitee.io/MQ/mq-rabbitmq.html RabbitMQ是一款开源的消息中间件，采用AMQP（高级消息队列协议）作为底层协议，提供了可靠的消息传递机制、灵活的路由方式以及多种消息发布/订阅模式等特性，被广泛应用于分布式系统、微服务架构等场景中 数据发布方式 RabbitMQ支持多种消息发布方式，主要包括以下几种： 1. P2P（点对点）模式 P2P模式是最简单的消息发布方式，即消息生产者直接将消息发送到指定的队列中，消费者通过消费该队列中的消息来获取数据 2. 发布/订阅模式 发布/订阅模式是指生产者将消息发送到一个交换机（exchange）中，而消费者则创建一个或多个队列并绑定到该交换机上，从而获取该交换机中的消息 在发布/订阅模式中，可以使用Fanout类型的exchange，该类型的交换机将消息广播给所有绑定到该交换机上的队列 3. Routing模式（路由模式） Routing模式是指生产者将消息发送到一个Direct类型的交换机中，交换机将消息交给符合...</div></div></div></a><a class="pagination-related" href="/Spring/Spring-life-cycle.html" title="Spring生命周期"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-05-28</div><div class="info-item-2">Spring生命周期</div></div><div class="info-2"><div class="info-item-1"> [原创]个人理解，请批判接受，有误请指正。转载请注明出处: https://heyfl.gitee.io/Spring/Spring-life-cycle.html 以以下为准： 1. 获取beanDefinition 通过loadBeanDefinitions() -&gt; 读取配置文件 -&gt; 解析配置文件 -&gt; 封装成BeanDefinition -&gt; 注册到BeanDefinitionRegistry的beanDefinitionMap中 扩展1:BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry 获取BeanDefinitionRegistry，增删改BeanDefinition，因为后续按此顺序创建 扩展2:BeanFactoryPostProcessor.postProcessBeanFactory BeanDefinition加载完成之后，但实例化bean之前进行一些额外的处理 这时候所有的bean定义都已加载，但还没有实例化任何bean。...</div></div></div></a><a class="pagination-related" href="/Spring/Spring-events.html" title="Spring常见事件"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-12</div><div class="info-item-2">Spring常见事件</div></div><div class="info-2"><div class="info-item-1"> [转载]个人理解，请批判接受，有误请指正。转载请注明出处: https://heyfl.gitee.io/Spring/Spring-events.html ContextRefreshedEvent：表示ApplicationContext已经初始化或刷新完成时触发。通常在应用程序启动时使用，用来执行初始化操作 ContextStartedEvent：表示ApplicationContext已经启动时触发。通常在应用程序启动时使用，用来执行一些启动任务 ContextStoppedEvent：表示ApplicationContext已经停止时触发。通常在应用程序停止时使用，用来执行一些清理任务 ContextClosedEvent：表示ApplicationContext已经关闭时触发。通常在应用程序关闭时使用，用来执行一些清理任务 RequestHandledEvent：表示Web请求已经处理完成时触发。通常在Web应用程序中使用，用来记录日志或统计数据 ApplicationStartedEvent：表示Spring Boot应用程序已经启动完成时触发。通常在Spri...</div></div></div></a><a class="pagination-related" href="/Spring/Spring-Circular-Dependencies.html" title="【Spring源码分析】循环依赖的处理"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-05-22</div><div class="info-item-2">【Spring源码分析】循环依赖的处理</div></div><div class="info-2"><div class="info-item-1"> [原创]个人理解，请批判接受，有误请指正。转载请注明出处: https://heyfl.gitee.io/Spring/Spring-Circular-Dependencies.html 看源码的同学可以查看我的GitHub 上面在官方的基础上加入了大量中文注释，帮助理解 要了解的知识 什么是循环依赖 graph LR A-->B B-->C C-->A 存在哪些循环依赖 Setter循环依赖(可以被解决) 构造循环依赖(报错) 基于Prototype类型的循环依赖(报错) Bean的创建步骤 看源码的同学可以找到源码： 环节1~4的代码在AbstractAutowireCapableBeanFactory#doCreateBean方法中 环节5的代码在DefaultSingletonBeanRegistry#getSingleton(String,ObjectFactory)方法的addSingleton(beanName, singletonObject);中 Spring是怎么处理循环依赖的（对于单例Bean） 实现原理 Spring在创建...</div></div></div></a><a class="pagination-related" href="/MQ/mq-common-problem.html" title="MQ常见问题及其处理方案"><img class="cover" src="/images/mq-common-problem/img.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-01-09</div><div class="info-item-2">MQ常见问题及其处理方案</div></div><div class="info-2"><div class="info-item-1"> [原创]个人理解，请批判接受，有误请指正。转载请注明出处: https://heyfl.gitee.io/MQ/mq-common-problem.html 基于Rabbitmq：</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/img.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">花火</div><div class="author-info-description">技术_转型之路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" href="https://github.com/xxxxxx" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-10-25"><span class="toc-number">1.</span> <span class="toc-text">2022-10-25</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%89%8D%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">目前本地缓存使用的方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-10-20"><span class="toc-number">2.</span> <span class="toc-text">2022-10-20</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%B8%AD%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%8411%E4%B8%AA%E6%89%A9%E5%B1%95%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">Spring中最常用的11个扩展点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-09-02"><span class="toc-number">3.</span> <span class="toc-text">2022-09-02</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hystrix%E7%86%94%E6%96%AD%E9%85%8D%E7%BD%AE"><span class="toc-number">3.1.</span> <span class="toc-text">Hystrix熔断配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-08-11"><span class="toc-number">4.</span> <span class="toc-text">2022-08-11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%87%8F%E5%B0%91Option%E8%AF%B7%E6%B1%82"><span class="toc-number">4.1.</span> <span class="toc-text">前端跨域请求减少Option请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2022-06-03"><span class="toc-number">5.</span> <span class="toc-text">2022-06-03</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#POJO%E3%80%81JavaBeans%E3%80%81BO%E3%80%81DTO-%E5%92%8C-VO-%E3%80%81DO%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text">POJO、JavaBeans、BO、DTO 和 VO 、DO之间的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-06-01"><span class="toc-number">6.</span> <span class="toc-text">2021-06-01</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#System-arraycopy%E6%96%B9%E6%B3%95%E5%92%8CArrays-copyOf"><span class="toc-number">6.1.</span> <span class="toc-text">System.arraycopy方法和Arrays.copyOf()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-05-20"><span class="toc-number">7.</span> <span class="toc-text">2021-05-20</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ES-%E5%88%86%E8%AF%8D"><span class="toc-number">7.1.</span> <span class="toc-text">ES 分词</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-02-26"><span class="toc-number">8.</span> <span class="toc-text">2021-02-26</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HBASE-%E5%88%97%E6%97%8F-RowKey"><span class="toc-number">8.1.</span> <span class="toc-text">HBASE 列族,RowKey</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-02-08"><span class="toc-number">9.</span> <span class="toc-text">2021-02-08</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E8%A6%81%E6%90%9E%E6%87%82%E7%9A%84%E4%BA%8B%E6%83%85"><span class="toc-number">9.1.</span> <span class="toc-text">最近要搞懂的事情</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-02-07"><span class="toc-number">10.</span> <span class="toc-text">2021-02-07</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8D%E7%A8%8D%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B2020%E5%B9%B4%E5%B9%B2%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9BP%E5%A4%A7%E7%82%B9%E7%9A%84%E4%BA%8B"><span class="toc-number">10.1.</span> <span class="toc-text">稍稍记录一下2020年干过的那些P大点的事</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%A0%E5%B0%B1%E4%B8%9A%E5%8A%A1%E2%80%94-%E5%92%8B%E7%8E%A9"><span class="toc-number">10.2.</span> <span class="toc-text">数据造就业务—&gt;咋玩???</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2021-01-25"><span class="toc-number">11.</span> <span class="toc-text">2021-01-25</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81ZK%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%8E%9F%E7%90%86-%E2%80%93-%E6%9C%80%E8%BF%91%E7%94%A8%E5%BE%97%E5%B0%91%E8%80%81%E6%98%AF%E5%BF%98%E8%AE%B0%EF%BC%8C%E8%BF%98%E6%98%AF%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%90%A7"><span class="toc-number">11.1.</span> <span class="toc-text">一、ZK事件回调原理 – 最近用得少老是忘记，还是记录一下吧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2020-12-14"><span class="toc-number">12.</span> <span class="toc-text">2020-12-14</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-ElasticSearch%E5%8E%9F%E7%90%86"><span class="toc-number">12.1.</span> <span class="toc-text">一、 ElasticSearch原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2020-11-18"><span class="toc-number">13.</span> <span class="toc-text">2020-11-18</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-MYSQL%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84-%E2%80%93-%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86"><span class="toc-number">13.1.</span> <span class="toc-text">一、 MYSQL是怎么运行的 – 连接原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2020-09-24-%E5%A5%BD%E4%B9%85%E6%B2%A1%E5%81%9A%E8%AE%B0%E5%BD%95%E4%BA%86%E2%80%A6"><span class="toc-number">14.</span> <span class="toc-text">2020-09-24(好久没做记录了…)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-DB-%E7%9C%8B%E4%BC%BC%E5%8C%B9%E9%85%8D%E5%88%B0%E7%B4%A2%E5%BC%95-%E4%BD%86%E6%98%AF%E6%B2%A1%E6%9C%89%E8%B5%B0%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">14.1.</span> <span class="toc-text">一、 DB 看似匹配到索引,但是没有走索引的情况(注意事项)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-DB-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E6%9F%A5%E7%9C%8B-%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5"><span class="toc-number">14.2.</span> <span class="toc-text">二、 DB 执行计划查看&amp;&amp;死锁排查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">14.2.1.</span> <span class="toc-text">执行计划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5"><span class="toc-number">14.2.2.</span> <span class="toc-text">死锁排查</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81ES-%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87"><span class="toc-number">14.3.</span> <span class="toc-text">三、ES 提高查询效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ES%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">14.4.</span> <span class="toc-text">四、ES存储结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-12-19"><span class="toc-number">15.</span> <span class="toc-text">2019-12-19</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka"><span class="toc-number">15.1.</span> <span class="toc-text">Kafka</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-Sentinel-Jedis"><span class="toc-number">15.2.</span> <span class="toc-text">Redis-Sentinel&amp;Jedis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Sentinel%E9%9B%86%E7%BE%A4%E8%8E%B7%E5%8F%96Redis%E4%B8%BB%E8%8A%82%E7%82%B9%E5%8E%9F%E7%90%86"><span class="toc-number">15.2.1.</span> <span class="toc-text">通过Sentinel集群获取Redis主节点原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Jedie%E7%9A%84Key%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E5%AD%98%E5%85%A5Redis%E7%9A%84%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84"><span class="toc-number">15.2.2.</span> <span class="toc-text">Jedie的Key是如何被存入Redis的某个节点的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-Sentinel%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9%E7%9A%84"><span class="toc-number">15.2.3.</span> <span class="toc-text">Redis-Sentinel模式是如何扩容的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Jedis%E4%B8%80%E8%87%B4%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">15.2.4.</span> <span class="toc-text">Jedis一致性分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-11-28"><span class="toc-number">16.</span> <span class="toc-text">2019-11-28</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#git-rebase-i-HEAD-2"><span class="toc-number">16.1.</span> <span class="toc-text">git rebase -i HEAD~2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hibernate-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">16.2.</span> <span class="toc-text">Hibernate 基本知识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-11-25"><span class="toc-number">17.</span> <span class="toc-text">2019-11-25</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93count"><span class="toc-number">17.1.</span> <span class="toc-text">数据库count()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A"><span class="toc-number">17.1.1.</span> <span class="toc-text">官方解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#count-%E5%92%8C-count-1"><span class="toc-number">17.1.2.</span> <span class="toc-text">count(*) 和 count(1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#count-column%EF%BC%89"><span class="toc-number">17.1.3.</span> <span class="toc-text">count(column）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM-%E4%B8%8E-InnoDB"><span class="toc-number">17.1.4.</span> <span class="toc-text">MyISAM 与 InnoDB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DB-select-count%E9%80%9F%E5%BA%A6"><span class="toc-number">17.1.5.</span> <span class="toc-text">DB select count速度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">17.1.6.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-11-22"><span class="toc-number">18.</span> <span class="toc-text">2019-11-22</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">18.1.</span> <span class="toc-text">[垂直]分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-number">18.1.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%88%99"><span class="toc-number">18.1.2.</span> <span class="toc-text">原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%9C%BA%E6%99%AF%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">18.1.3.</span> <span class="toc-text">大数据量场景注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">18.1.4.</span> <span class="toc-text">提高性能的原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-11-20"><span class="toc-number">19.</span> <span class="toc-text">2019-11-20</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">19.1.</span> <span class="toc-text">数据库基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM%E4%B8%8EInnoDB%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">19.1.1.</span> <span class="toc-text">MyISAM与InnoDB索引的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-11-11"><span class="toc-number">20.</span> <span class="toc-text">2019-11-11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Elastic-Job"><span class="toc-number">20.1.</span> <span class="toc-text">Elastic-Job</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Elastic-Job%E5%85%B6%E4%BB%96"><span class="toc-number">20.2.</span> <span class="toc-text">Elastic-Job其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%B1%E6%95%88%E8%BD%AC%E7%A7%BB"><span class="toc-number">20.2.1.</span> <span class="toc-text">1. 失效转移</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-08-26"><span class="toc-number">21.</span> <span class="toc-text">2019-08-26</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E9%94%81"><span class="toc-number">21.1.</span> <span class="toc-text">MySQL锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81"><span class="toc-number">21.1.1.</span> <span class="toc-text">记录锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-number">21.1.2.</span> <span class="toc-text">间隙锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%97%B4%E9%9A%99%E9%94%81%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">21.1.2.1.</span> <span class="toc-text">使用间隙锁的条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81-Next-key-Locks"><span class="toc-number">21.1.2.2.</span> <span class="toc-text">临键锁(Next-key Locks)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81-Next-key-Locks-%E4%BE%8B%E5%AD%90"><span class="toc-number">21.1.2.2.1.</span> <span class="toc-text">临键锁(Next-key Locks) 例子:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E4%B8%B4%E9%94%AE%E9%94%81%E9%AA%8C%E8%AF%81"><span class="toc-number">21.1.2.2.2.</span> <span class="toc-text">非唯一索引临键锁验证</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E4%B8%B4%E9%94%AE%E9%94%81%E9%AA%8C%E8%AF%81"><span class="toc-number">21.1.2.2.3.</span> <span class="toc-text">唯一索引临键锁验证</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-08-22"><span class="toc-number">22.</span> <span class="toc-text">2019-08-22</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1-AOP%E5%A2%9E%E5%BC%BA"><span class="toc-number">22.1.</span> <span class="toc-text">Spring事务&#x2F;AOP增强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-LTW%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%9D%99%E6%80%81%E7%BB%87%E5%85%A5%EF%BC%88%E5%BA%94%E8%AF%A5%E4%B8%8D%E8%83%BD%E5%8F%AB%E5%81%9A%E4%BB%A3%E7%90%86%EF%BC%89"><span class="toc-number">22.2.</span> <span class="toc-text">Spring LTW实现的静态织入（应该不能叫做代理）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-08-01"><span class="toc-number">23.</span> <span class="toc-text">2019-08-01</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1"><span class="toc-number">23.1.</span> <span class="toc-text">Spring事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-7-20"><span class="toc-number">24.</span> <span class="toc-text">2019-7-20</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#seata"><span class="toc-number">24.1.</span> <span class="toc-text">seata</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-7-17"><span class="toc-number">25.</span> <span class="toc-text">2019-7-17</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1-Cglib"><span class="toc-number">25.1.</span> <span class="toc-text">Spring事务&#x2F;Cglib</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-5-20"><span class="toc-number">26.</span> <span class="toc-text">2019-5-20</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90GC%E6%97%A5%E5%BF%97%E3%80%91GC%E8%80%97%E6%97%B6%E8%A7%A3%E6%9E%90"><span class="toc-number">26.1.</span> <span class="toc-text">【GC日志】GC耗时解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-5-1"><span class="toc-number">27.</span> <span class="toc-text">2019-5-1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93MVCC"><span class="toc-number">27.1.</span> <span class="toc-text">数据库MVCC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">28.</span><span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MVVC%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">28.0.1.</span> <span class="toc-text">MVVC机制：</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-04-24"><span class="toc-number">29.</span> <span class="toc-text">2019-04-24</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E7%9A%84Lifecycle-SpringAppilication%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">29.1.</span> <span class="toc-text">Spring的Lifecycle (SpringAppilication生命周期)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-04-23"><span class="toc-number">30.</span> <span class="toc-text">2019-04-23</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%B5%8B%E8%AF%95%E7%B1%BB%E7%9A%84%E8%A7%84%E8%8C%83"><span class="toc-number">30.1.</span> <span class="toc-text">关于测试类的规范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-04-22"><span class="toc-number">31.</span> <span class="toc-text">2019-04-22</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Lookup"><span class="toc-number">31.1.</span> <span class="toc-text">Spring @Lookup</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">31.1.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83"><span class="toc-number">31.1.2.</span> <span class="toc-text">使用参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-04-21"><span class="toc-number">32.</span> <span class="toc-text">2019-04-21</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%89%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">32.1.</span> <span class="toc-text">架构设计三大原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-03-20"><span class="toc-number">33.</span> <span class="toc-text">2019-03-20</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-vs-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">33.1.</span> <span class="toc-text">策略模式 vs 命令模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">33.1.1.</span> <span class="toc-text">1. 策略模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">33.1.2.</span> <span class="toc-text">2. 命令模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%80%BB%E7%BB%93"><span class="toc-number">33.1.3.</span> <span class="toc-text">3. 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-03-15"><span class="toc-number">34.</span> <span class="toc-text">2019-03-15</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-vs-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">34.1.</span> <span class="toc-text">策略模式 vs 代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-v2"><span class="toc-number">34.1.1.</span> <span class="toc-text">1. 策略模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">34.1.2.</span> <span class="toc-text">2. 代理模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">34.1.3.</span> <span class="toc-text">2.1 动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-One-More-Thing"><span class="toc-number">34.1.4.</span> <span class="toc-text">3.One More Thing</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-03-12"><span class="toc-number">35.</span> <span class="toc-text">2019-03-12</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">35.1.</span> <span class="toc-text">Spring循环依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E9%80%89%E6%8B%A9"><span class="toc-number">35.2.</span> <span class="toc-text">Spring注入方式选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-03-11"><span class="toc-number">36.</span> <span class="toc-text">2019-03-11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">36.1.</span> <span class="toc-text">一、集合操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">36.1.1.</span> <span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9"><span class="toc-number">36.1.2.</span> <span class="toc-text">修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">36.1.3.</span> <span class="toc-text">其它</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Hystrix"><span class="toc-number">36.2.</span> <span class="toc-text">二、Hystrix</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-03-09"><span class="toc-number">37.</span> <span class="toc-text">2019-03-09</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-03-05"><span class="toc-number">38.</span> <span class="toc-text">2019-03-05</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81StringBuilder%E5%9C%A8%E9%AB%98%E6%80%A7%E8%83%BD%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95"><span class="toc-number">38.1.</span> <span class="toc-text">一、StringBuilder在高性能场景下的正确用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-03-01"><span class="toc-number">39.</span> <span class="toc-text">2019-03-01</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">39.1.</span> <span class="toc-text">一、分布式锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-02-22"><span class="toc-number">40.</span> <span class="toc-text">2019-02-22</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81ThreadLocal"><span class="toc-number">40.1.</span> <span class="toc-text">一、ThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-02-17"><span class="toc-number">41.</span> <span class="toc-text">2019-02-17</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">41.1.</span> <span class="toc-text">一、常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%842%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">41.2.</span> <span class="toc-text">二、字符串加载到字符串常量池的2种方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019-01-28"><span class="toc-number">42.</span> <span class="toc-text">2019-01-28</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis"><span class="toc-number">42.1.</span> <span class="toc-text">Mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">42.1.1.</span> <span class="toc-text">一级缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">42.1.2.</span> <span class="toc-text">二级缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2018-11-06"><span class="toc-number">43.</span> <span class="toc-text">2018-11-06</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E7%89%A9%E8%A6%81%E7%9C%8B%E5%9C%BA%E6%99%AF%E7%9A%84"><span class="toc-number">43.1.</span> <span class="toc-text">一、 分布式事物要看场景的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2018-11-06-v2"><span class="toc-number">44.</span> <span class="toc-text">2018-11-06</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81JVM%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%B8%8ETLAB-Thread-Local-Allocation-Buffer"><span class="toc-number">44.1.</span> <span class="toc-text">一、JVM逃逸分析与TLAB(Thread Local Allocation Buffer)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2018-10-19"><span class="toc-number">45.</span> <span class="toc-text">2018-10-19</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Feign-Consul-%E8%8E%B7%E5%8F%96%E5%8F%AF%E7%94%A8%E6%9C%8D%E5%8A%A1IP"><span class="toc-number">45.1.</span> <span class="toc-text">一、Feign Consul 获取可用服务IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Consul"><span class="toc-number">45.2.</span> <span class="toc-text">二、Consul</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2018-10-18"><span class="toc-number">46.</span> <span class="toc-text">2018-10-18</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%A4%9A%E6%9C%8D%E5%8A%A1%E7%9A%84%E3%80%90%E4%BA%8B%E5%8A%A1%E3%80%91%E9%98%BB%E5%A1%9E%EF%BC%88%E8%B7%A8%E6%9C%BA%E5%99%A8%EF%BC%89"><span class="toc-number">46.1.</span> <span class="toc-text">一、多服务的【事务】阻塞（跨机器）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2018-09-29"><span class="toc-number">47.</span> <span class="toc-text">2018-09-29</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%9A%84JSON%E6%95%B0%E6%8D%AE-%E5%BF%AB%E9%80%9F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AE%9E%E9%99%85%E6%95%B0%E6%8D%AE"><span class="toc-number">47.1.</span> <span class="toc-text">一、接口返回的JSON数据,快速转换为实际数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2018-09-29-v2"><span class="toc-number">48.</span> <span class="toc-text">2018-09-29</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-XX-PrintFlagsFinal"><span class="toc-number">48.1.</span> <span class="toc-text">一、-XX:+PrintFlagsFinal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2018-09-29-v3"><span class="toc-number">49.</span> <span class="toc-text">2018-09-29</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Feign%E9%87%8D%E8%AF%95"><span class="toc-number">49.1.</span> <span class="toc-text">一、Feign重试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="toc-number">49.2.</span> <span class="toc-text">二、超时时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Http%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB"><span class="toc-number">49.3.</span> <span class="toc-text">三、Http状态码分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81String"><span class="toc-number">49.4.</span> <span class="toc-text">四、String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81-Transaction"><span class="toc-number">49.5.</span> <span class="toc-text">五、@Transaction</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2018-09-28"><span class="toc-number">50.</span> <span class="toc-text">2018-09-28</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81JVM%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-number">50.1.</span> <span class="toc-text">一、JVM参数配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Feign%E5%89%8D%E5%90%8E%E7%AB%AF%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">50.2.</span> <span class="toc-text">二、Feign前后端全局异常处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2018-09-17"><span class="toc-number">51.</span> <span class="toc-text">2018-09-17</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%AD%A3%E7%A1%AE%E7%9A%84kill%E8%BF%9B%E7%A8%8B"><span class="toc-number">51.1.</span> <span class="toc-text">一、正确的kill进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2018-09-16"><span class="toc-number">52.</span> <span class="toc-text">2018-09-16</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81JDK8-%E7%A7%BB%E9%99%A4%E4%BA%86Perm"><span class="toc-number">52.1.</span> <span class="toc-text">一、JDK8+移除了Perm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81String-intern"><span class="toc-number">52.2.</span> <span class="toc-text">二、String.intern</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-XX-MetaspaceSize"><span class="toc-number">52.3.</span> <span class="toc-text">二、-XX:MetaspaceSize</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2018-09-06"><span class="toc-number">53.</span> <span class="toc-text">2018-09-06</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%8E%B7%E5%8F%96%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID"><span class="toc-number">53.1.</span> <span class="toc-text">一、获取全局唯一ID</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2018-09-05"><span class="toc-number">54.</span> <span class="toc-text">2018-09-05</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81SQL%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B4%A2%E5%BC%95"><span class="toc-number">54.1.</span> <span class="toc-text">一、SQL的强制索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E7%90%86%E8%A7%A3"><span class="toc-number">54.2.</span> <span class="toc-text">二、接口幂等理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">54.3.</span> <span class="toc-text">三、IO多路复用模型</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day-English.html" title="每天进步一点点 - English"><img src="/images/make-a-little-progress-every-day/%E6%AF%8F%E5%A4%A9%E8%BF%9B%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%20-%20English.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="每天进步一点点 - English"></a><div class="content"><a class="title" href="/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day-English.html" title="每天进步一点点 - English">每天进步一点点 - English</a><time datetime="2099-12-05T02:44:56.000Z" title="发表于 2099-12-05 10:44:56">2099-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day-Basic-Technology.html" title="每天进步一点点 - 基础技术篇">每天进步一点点 - 基础技术篇</a><time datetime="2099-09-05T06:44:56.000Z" title="发表于 2099-09-05 14:44:56">2099-09-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/idea/performance-optimization-core-ideas.html" title="性能优化核心思想">性能优化核心思想</a><time datetime="2025-12-15T14:58:59.461Z" title="发表于 2025-12-15 22:58:59">2025-12-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/design/precise-timing-task-design.html" title="精准定时任务设计思路">精准定时任务设计思路</a><time datetime="2025-12-15T14:58:59.457Z" title="发表于 2025-12-15 22:58:59">2025-12-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/SA/Study/Alipay-Payment-Process-Analysis.html" title="支付宝支付流程">支付宝支付流程</a><time datetime="2025-12-10T12:56:10.000Z" title="发表于 2025-12-10 20:56:10">2025-12-10</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2025 By 花火</span><span class="framework-info"><span>框架</span> <a href="https://hexo.io" rel="external nofollow noopener noreferrer" target="_blank">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题</span> <a href="https://github.com/jerryc127/hexo-theme-butterfly" rel="external nofollow noopener noreferrer" target="_blank">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="180" alpha="0.6" zindex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/shizuku.model.json"},display:{position:"left",width:100,height:170},mobile:{show:!1}})</script></body></html>