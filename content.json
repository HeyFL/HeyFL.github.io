{"pages":[],"posts":[{"title":"关于我","text":"蔡振谦的个人简历 联系方式 手机：15625290660 Email：361389383@qq.com.com QQ/微信号：361389383 GitHub: https://github.com/HeyFL 博客: https://heyfl.github.io 个人信息 蔡振谦/本科/男/199109 工作年限：5年 期望职位：Java开发 期望行业: 互联网/金融 期望城市：深圳 工作经历 深圳市递四方信息科技有限公司 （ 2017年09月 ~ ） 任职于递四方信息科技公司末端团队，该部门主要负责物流末端相关业务，部门有20多个正在开发、运行的微服务体系项目； 项目为基于SpringCloud框架微的服务体系项目，通过Jenkins构建发布到对应服务器，服务之间通过MQ、http、dubbo通讯； 在该部门主要负责GRID产品线/G2G产品线的需求分析与设计，并选择合理的方案实现核心难题。 项目经验 G2G产品线(启运仓) [Now] 包括以下系统 G2G仓内运营系统 G2G仓内作业系统＊N 个人在项目职责： 系统的架构设计 其核心模块(预报/调度分发/结果回传/数据权限等)的详细设计/开发 GRID产品线(包括接单/调度/运营/门店作业部分) 项目描述 跨国部署的微服务体系，含4个业务项目（主要） : 1.接单平台 2.调度中心 3.运营中心 4.作业系统（提供门店PC端，派送揽收APP端服务） 个人在项目职责： 负责核心模块(下单/其他接单系统与客户系统对接的预报/共用模块) [参与]系统的架构设计 Other More 期间,自发为部门开发共用模块/优化,包含但不仅限如下: 基础依赖: 统一的业务异常/系统异常 Http统一的返回对象 Redis分布式锁工具类 基于Redis的幂等注解 消息级延迟补偿 统一异常处理(统一解决了异常日志输出及返回问题) 统一国际化工具类(减少了团队对[前端]请求的后端国际化的工作量) 其他 定义异常处理/抛出规范 定义Consul配置规范(减少发版比对时的困难) 定义RabbitMQ在SpringBoot下的队列定义规范 北京思特奇信息技术股份有限公司 （ 2015年04月 ~ 2017年08月 ） 对应项目经验 联通业务支撑平台 项目描述 联通内部员工使用的业务受理系统，包括：业务受理、IT 需求、调账管理、销售支撑、产品管理、系统管理、经营分析等；技术体系包含: 高可用：Keepalive+Nginx 后台分布式：使用了各个模块独立服务器独立应用、独立数据库表（zookeeper+redis+工作流+共享 session单点登录）； 前端技术：JQuery+Ajax+H5+百度Fis+RequireJS+TmodJS+Nginx+Keepalive 后台技术：zookeeper+redis工作流+共享 session单点登录+类似SpringMVC+Spring+Ibatis/Mybatis+Maven 个人在项目职责 调账管理 分析设计开发、产品管理模块的维护 业支『前台整体架构』与『后台整体架构』维护、改造 技能清单 以下均为我使用的技能 Java（看完《深入理解JVM虚拟机》） Spring（看完《Spring源码深度解析》） SpringCloud MQ ，Redis， Consul MySQL SVN/Git/Jenkins 理解分布式事务 Mybatis 致谢 感谢您花时间阅读我的简历，期待能有机会和您共事。","link":"/about/about.html"},{"title":"Spring-Cloud服务在Consul中的多实例注册问题","text":"[原创]个人理解，请批判接受，有误请指正。转载请注明出处: https://heyfl.github.io/Bug-Log/bug_in_spring-cloud_instance_registered_with_consul.html 背景 公司实现微服务化并原来使用的Dubbo+Zookeeper实现应用间的服务调用，考虑到Dubbo不在维护最近想要切换为Spring Cloud+Consul 环境 Spring Cloud: Edgware.SR3 Spring-boot: 1.5.13.RELEASE 12345678910111213141516&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.13.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Edgware.SR3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 根据网上流传的博客我们使用的配置为: 1spring.cloud.consul.discovery.instance-id=${spring.application.name}-${server.port} 也就是【服务名】+【端口】的形式来标识Consul上的一个服务 1. 第一个问题 已注册上Consul的服务被覆盖(采用【服务名】+【端口】的形式) 在我们实际开发测试时候发现 无论服务起了多少个实例，最终展示到Consul都只有一个 : 怀疑是Consul以【服务名】+【端口】为实例的唯一标示，导致【后起来的服务】覆盖掉【原来已经注册到Consul上的服务】了 ，我们通过Feign调用时发现也确实是如此 1.1. Kill 第一个问题 上Spring官方文档轻松找到解决方案(有问题还是官方文档好) 1${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}} 原理就是每次启动时注册的实例ID都为【服务名】+【随机数】： 通过这种形式，可以让每一个服务提供者（实例）都有效地注册到Consul上，并且Consul上的每一个Instance都能唯一映射到每一个提供者上 2. 第二、第三个问题 2.1. 服务器通过Kill -9的重启脚本快速重启导致一个提供者在Consul上注册了多次(Consul注册的实例数&gt;实际提供者数) 首先，我们要知道当系统执行kill-9命令的时候会立马强制关闭该进程，程序很可能正在处理请求中，同时也占用了一些的资源，本来需要做一些善后才能正常、安全的结束，但是你一个kill-9命令过来，程序就措手不及了。 结合上述情况，实际上程序非正常重启，已经注册在consul上的服务没有被反注册，服务重新启动之后又重新的注册了一个新的服务上去了（而且重启后以前的服务在Consul心跳机制下海认为是可用的），一个服务就在Consul注册了多次了 这种情况可以修改重启脚本解决： 通过Kill -15直接关闭提供者进程 可以参考这篇文章 2.2. 【服务名】+【随机数】的InstanceID不能提供足够信息帮助我们快速定位问题 上面的方案可以解决我们遇到的问题，但是有一点不足的是，Consul上看到的InstanceID都是【服务名】+【随机数】，随机数没有可读性可言， 我们压根不能根据这个InstanceID一眼看出的它的服务提供者是谁。不便于我们排查问题 进一步优化 其实最好就是使用【服务名】+【机器IP】+【端口】的形式，这样既能通过唯一标示服务提供者解决 Consul服务被覆盖的问题 也能方便我们运维开发时快速知道当前服务的提供者列表，快速定位问题 最终方案 1spring.cloud.consul.discovery.instance-id=${spring.application.name}:${spring.cloud.client.ipAddress}:${server.port}","link":"/Bug-Log/bug_in_spring-cloud_instance_registered_with_consul.html"},{"title":"分布式事务解法","text":"[原创]个人理解，请批判接受，有误请指正。转载请注明出处: https://heyfl.github.io/Distributed/How-To-Use-Distributed-Transaction.html 可搭配参考我的GitHub: 分布式事务.xmind 参见分布式事务有哪些 1. 基于XA协议的全局事务 (强一致性) 使用情况：一个工程对多个数据源（数据库需要支持XA协议） 基本功能：数据库时间功能+开源组件（知名的分布式事务管理器主要有atomikos、bitronix、narayana。其中，仅atomikos支持XA和TCC两种机制，bitronix、narayana仅支持XA机制。） 原理：2PC 单服务多数据库使用全局事务 缺点：XA协议比较简单，成本较低，但是其单点问题，以及不能支持高并发(由于同步阻塞)依然是其最大的弱点(主要),2PC本身的缺陷也是一方面原因(次要)。 2. TCC(强一致性) 使用情况：多系统 多数据源 原理：编程式事务，每个业务都要开发try，confirm，cancel 3个方法实现 try-&gt;调用所有服务,把所有资源设置为中间状态(如订单设置为支付中,库存设置为冻结) confirm-&gt;把所有资源状态设置为完成(支付完成) cancel-&gt; 把所有资源状态回滚回try前 缺点：程序复杂度高，confirm、cancel方法需要实现幂等 3. 基于可靠消息服务的分布式事务–MQ消息队列(最终一致性) 使用情况： 多系统 多数据源 原理：利用本地事务及MQ的事务消息（其实也不一定要用），确保本地事务未完成、消息发送出去；理想地认为对方一定能正确、成功消费消息； 缺点： 数据有一小段时间不一致 对方系统出现问题，不能正常消费信息，导致数据长期不一致 4. (最大努力通知)基于[不可靠]消息服务的分布式事务–MQ消息队列(最终一致性) 使用情况： 多系统 多数据源 原理：通过MQ延迟队列等实现的延迟通知服务, 通知服务会每隔1,5,10,30分钟重复通知 , 到达最大通知次数后, 需要人工通知或重置重试次数 优势(比基于可靠消息服务的分布式事务) 允许消费方短期异常(通过1,5,10,30分钟的间隔重试) 缺点： 数据有一小段时间不一致 对方系统出现问题，不能正常消费信息，导致数据长期不一致 编码比基于可靠消息服务的分布式事务复杂一些,需要实现延迟队列、自产自销+Http请求等实现重复通知 分布式事务选型 分布式事务选型主要要看场景，我们以流量充值作为例子 流量充值涉及到订单支付 金钱交易严格用tcc 订单支付完后要给用户增加积分 这种情况这个必要成功（毕竟是内部系统），用最终消息一致性方案就行了; 订单支付完后还要给用户发送一条短信 短信一般是跟电信运营商的第三方接口对接，有可能成功有可能失败，用最大努力通知方案(每隔1,5,10,30分钟重复通知 直到达到最大重试次数)","link":"/Distributed/How-To-Use-Distributed-Transaction.html"},{"title":"java虚拟机栈的内存结构","text":"[原创]个人理解，请批判接受，有误请指正。转载请注明出处: https://heyfl.github.io/JVM/JVM-Memory-Structure-Stack.html 学习JVM的可以去我的GitHub 上查看我的Xmind详细笔记 对整本《深入理解JVM》都有详尽的笔记，帮助理解 一、 前言 Java栈分为两种： Java虚拟机栈： 描述java【方法】执行的【内存模型】 每个线程进入每个方法对应一个栈帧 本地方法栈(本文不做描述) 同虚拟机栈，区别在于：虚拟机栈服务于Java方法（字节码），本地方法栈服务于Native方法 本文主要讲Java虚拟机栈的内存结构 一图胜千言 二、Java虚拟机栈的组成： 1. 栈帧 每个方法对应一个栈帧，在线程运行到该方法时才创建，随着方法结束而销毁 2. 线程栈 栈帧内存在线程内存上进行分配，每条线程能为栈帧分配的总大小最大值为-Xss 为了方便，我们这里 [把这条线程对应的内存] 称为 [线程栈] 3. Java虚拟机栈 Java虚拟机栈是描述java【方法】执行的【内存模型】–&gt; 实际上它是 当前时刻[所有的线程栈]集合的统称 三、 Java虚拟机栈会出现的异常: 经过上面的描述，我们可以清晰地知道： 【Java虚拟机栈】由【当前所有的线程栈】组成 【每个线程栈由】由【这条线程所对应的所有栈帧】组成 因此，可能会出现2种内存溢出的情况 （也可参考Oracle JavaSE8的JVM规范：The Structure of the Java Virtual Machine-Java Virtual Machine Stacks） [x] 线程栈溢出(Stack Overflow)： 某条线程对应的栈帧内存之和 超过线程栈内存的最大值-Xss 根据栈帧的定义可以理解到：该问题主要是一条线程在某一时间点同时存在于多个方法中（网上称作方法深度过深，最常见的案例就是递归调用） [x] 从Java虚拟机栈层面溢出(OOM)： 当前时刻[所有的线程栈]内存之和 超过 Java虚拟机栈所允许的最大值 导致这个问题的原因是当前新建的线程数太多(当然,换句话也以说是当前计算机可分配给Java虚拟机的空间太少) 每条线程占用的空间都未-Xss，新建多了也就OOM了；这种情况一般较少发生，主要有以下因素： 系统对线程数上限的限制 线程过多，会导致CPU崩溃，也就是说系统早就挂了 Java虚拟机栈所允许的最大值：JVM 可分配内存-其他JVM内存结构空间最大值(主要是堆)–&gt;剩下的作为栈的总空间最大值(来自《深入理解Java虚拟机》P54) 四、验证 4.1. 线程栈溢出（StackOverFlow） 通过-Xss调整线程栈大小测试[线程栈最大占用内存为-Xss] 1234567891011121314151617181920212223242526272829private static AtomicLong i = new AtomicLong(0);public static void main(String[] args) throws InterruptedException { //1. 测试错误StackOverFlow testStackOverFlow(); //2.测试错误OOM //testOOM();}/** * StackOverFlow每次深度不一样是因为JIT优化 * -Djava.compiler=NONE禁用JIT优化后每次深度一样 * * * 测试参数：-Xss256k*/private static void testStackOverFlow() { //new Thread(() -&gt; { StackErrorTest testData = new StackErrorTest(); try { testData.test1(); } catch (Throwable e) { System.out.println(Thread.currentThread().getName() + \" \" + i.get()); } //}).start();} 运行参数设置-Xss256k -Djava.compiler=NONE,多次运行输出结果一致: 1main 1882 运行参数设置-Xss512k -Djava.compiler=NONE,多次运行输出结果一致: 1main 4861 2.2.2 从Java虚拟机栈溢出（OOM） 注意 Mac有单进程线程数量限制,16G的Mac电脑限制为5000,修改方式参考(不好意思 不能修改 ) 在一些配置较低的电脑可能会死机，请小心运行 建议使用虚拟机运行 影响因素 描述 系统限制 系统允许进程的最大线程数 -Xss 每条线程栈占用的内存 -Xmx 堆空间最大值 详细验证可以参考这篇文章","link":"/JVM/JVM-Memory-Structure-Stack.html"},{"title":"JVM内存结构-总纲","text":"[原创]个人理解，请批判接受，有误请指正。转载请注明出处: https://heyfl.github.io/JVM/JVM-Memory-Structure-Menu.html 学习JVM的可以去我的GitHub 上查看我的Xmind详细笔记 对整本《深入理解JVM》都有详尽的笔记，帮助理解 前言 网上有不少描述JVM内存结构的文章，但是要么比较老久了，要么描述有误，今天根据自己的理解整理下，有误请指正。 整体图解 程序计数器 记录Java程序运行到哪里 线程私有，可以看做当前线程执行到哪行【字节码】 字节码解析器工作就是通过改变这个【计数器】来选择下一行要执行什么，分支、循环、线程恢复都依赖于它 若为Java方法，则记录当前执行的字节码指令地址； 若执行的是native方法，则为空 Java 虚拟机栈 描述java【方法】执行的【内存模型】 每个方法对应一个栈帧,在线程运行到该方法时才创建 一条线程拥有的栈帧之和最大为-Xss(我们这里把它叫做线程栈) 当前所有线程栈之和=当前Java虚拟机栈已用大小 Java虚拟机栈总空间最大值：JVM 可分配内存-堆最大值-其他空间最大值–&gt;剩下的作为栈的总空间最大值 详细可参考: java虚拟机栈的内存结构 栈帧结构(待填坑) Java虚拟机栈异常及其处理方案(待填坑) 本地方法栈 同虚拟机栈，区别在于：虚拟机栈服务于Java方法（字节码），本地方法栈服务于Native方法 堆 随JVM启动而创建，是虚拟机最大的一块内存，被所有线程共享 存放着对象与数组等一切new出来的对象 垃圾收集器主要管理的区域 还存放着常量池 (1.7及以后的版本,都移到堆里存储了,需要注意的地方比较多 后面会说 不在这里描述) 详细可参考我另外的这篇博客(待填坑) 字符串常量池 存放字符串常量池,不同JDK版本存放的内容不一样 **1. 怎样的String会被存到常量池 简单来说以下这些情况都会存入常量池: 直接使用双引号声明出来的String对象 调用intern()方法 这个可以参考这篇《深入解析String#intern》 何时存放String字符串也可以参考 String放入运行时常量池的时机与String.intern()方法解惑 2. 存储结构在不同JDK下的区别 JDK≤6 常量池存于方法区中 常量池里的内容全部为字符串具体的值 JDK≥7 常量池存于堆中来自官网原文:the string pool was relocated to the heap 存储的东西为字符串值或引用(引用堆里的值),具体可以参考美团的《深入解析String#intern》 3. String 加载进字符串常量池的方式/时机 首先要知道字符串常量池是位于运行时常量池中的 编译完刚启动: 加载String进字符串常量池的过程大致为： graph LR A[编译后的class文件中的class常量池] B[运行时常量池中的字符串常量池] A-->B; 运行期间 graph LR A[代码] B[运行时常量池中的字符串常量池] A-->B; 参考《常量池结构及其加载过程》 方法区(永久代) 存放类的结构：版本、常量、全局变量、静态变量、方法、接口、即JIT编译后的代码等信息（JDK8后完全移出方法区 可以参考:Java 8: From PermGen to Metaspace) 具体里面存了啥 可以参考 JVM虚拟机结构 (不在JVM里的)元数据区 JDK8开始,替代方法区的存在；很大程度的避免了因为类加载过多导致的\bOOM问题 实际上元数据区不属于JVM内存的一部分；其为本地内存的一部分；大小取决于\b开发人员配置或可用的本地内存大小 有一点必须注意的是： -XX:MetaspaceSize=128m 不是初始元空间大小,而是达到了128m后才会对该区域进行GC 初始化大小20.8m 默认MetaspaceSize也是20.8m","link":"/JVM/JVM-Memory-Structure-Menu.html"},{"title":"1分钟教你redis集群搭建（2服務器）","text":"遇到有疑惑的可参考这个链接 注意: 关闭redis集群不能直接kill掉进程，或者关机，我们要通过命令redis-cli -p 7001 shutdown进行关闭，这样在关闭之前，数据才能够进行保存 1. 安装 redis 详：略 2. 创建 n 个 redis.conf 文件(redis 集群需要至少6个节点[3主3从]) 详： 1234567daemonize yes //redis后台运行pidfile /var/run/redis_7000.pid //pidfile文件对应7000,7002,7003port 7000 //端口7000,7002,7003cluster-enabled yes //开启集群 把注释#去掉cluster-config-file nodes_7000.conf //集群的配置 配置文件首次启动自动生成 7000,7001,7002cluster-node-timeout 5000 //请求超时 设置5秒够了appendonly yes //aof日志开启 有需要就开启，它会每次写操作都记录一条日志 3. 用redis.server 启动 redis 12345678101服務器redis-server ./7000/redis.confredis-server ./7001/redis.confredis-server ./7002/redis.conf102服務器redis-server ./7003/redis.confredis-server ./7004/redis.confredis-server ./7005/redis.conf 4. 安装 redis (不安装也行 主要是为了安装redis-trib.rb脚本而已) 1gem install redis（需要ruby rubygems） 5. 关联集群 1redis-trib.rb create --replicas 1 172.16.86.101:7000 172.16.86.101:7001 172.16.86.101:7002 172.16.86.102:7003 172.16.86.102:7004 172.16.86.102:7005 6. 检查集群是否搭建完成 12345678910111213[chris-cai@localhost cluster]$ redis-cli -c -p 7000127.0.0.1:7000&gt; CLUSTER INFOcluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:6cluster_my_epoch:1cluster_stats_messages_sent:228cluster_stats_messages_received:228 其他说明 1. redis常用命令放到Linux系统目录中，方便直接使用 这3个文件可以复制到/usr/local/bin 中，日后可以直接在linux命令行调用，无需切换目录输入路径等 123redis-cliredis-serverredis-trib.rb 2. 常用命令 1234redis-cli -h 172.16.86.102 -p 7003redis-cli -c -p 7003cluster nodesCLUSTER INFO 让0b00721a509444db793d28448d8f02168b94bd38成为7000的从节点 1redis-cli -c -p 7000 cluster replicate 0b00721a509444db793d28448d8f02168b94bd38","link":"/redis/Redis-Install-Settring.html"},{"title":"Redis集群--sentinel 与 cluster的区别","text":"[原创]个人理解，请批判接受，有误请指正。转载请注明出处: https://heyfl.github.io/redis/Different-Between-Sentinel-And-Cluster.html 一、sentinel 与 cluster的区别 Sentinel的作用 监控+自动故障迁移(自动升主) 定期监控redis是否按照预期良好地运行; 当一个master节点不可用时，能够选举出master的多个slave 并令其自动升主 PS. sentinel本身支持集群 Cluster的作用 分布式集群 对Redis进行16384个槽按照节点分片(默认为均分16384个槽到每个节点) 主从复制 监控+自动故障迁移(同Sentinel) 总结 Cluster 包含Sentinel的功能 Sentinel主要用于： 不需要分片的情况 监控+自动升主进程不想与Redis服务器部署在一起的情况 Redis3.x以下","link":"/redis/Different-Between-Sentinel-And-Cluster.html"},{"title":"Redis分片方案概要(Cluster or Codis)","text":"[原创]个人理解，请批判接受，有误请指正。转载请注明出处: https://heyfl.github.io/redis/Redis-Partitioning.html Redis分片方案概要(Cluster or Codis) 客户端分片 常见的主要是Memcached 通过客户端Hash等方式决定数据要存到哪个节点 服务器端分片 Codis分片方案 Codis是一整套缓存解决方案，包含高可用、数据分片、监控、管理、动态扩态 etc. 走的是 Client-&gt;代理-&gt;redis，一定规模后基本都采用这种方式 限制 批量操作可能受影响: 不支持pipeline/watch/scan等批操作 不支持事务 支持mset/mget 官方Redis Cluster分片方案 走的是Client-&gt;redis server jump redis server 限制 批量操作可能受影响: mset/mget/pipeline/watch/scan等批操作需要所有key都存在以同个节点上 并且手动分片期间,批操作不可用 (参考官方文档的Implemented subset) 客户端必须支持集群协议 不支持事务","link":"/redis/Redis-Partitioning.html"},{"title":"【Spring源码分析】循环依赖的处理","text":"[原创]个人理解，请批判接受，有误请指正。转载请注明出处: https://heyfl.github.io/Spring/Spring-Circular-Dependencies.html 看源码的同学可以查看我的GitHub 上面在官方的基础上加入了大量中文注释，帮助理解 要了解的知识 什么是循环依赖 graph LR A-->B B-->C C-->A 存在哪些循环依赖 Setter循环依赖(可以被解决) 构造循环依赖(报错) 基于Prototype类型的循环依赖(报错) Bean的创建步骤 看源码的同学可以找到源码： 环节1~4的代码在AbstractAutowireCapableBeanFactory#doCreateBean方法中 环节5的代码在DefaultSingletonBeanRegistry#getSingleton(String,ObjectFactory)方法的addSingleton(beanName, singletonObject);中 Spring是怎么处理循环依赖的（对于单例Bean） 实现原理 Spring在创建单例BeanA的时候会先把BeanA(仅执行完构造方法)给放到三级缓存中， 当其他Bean或业务代码在BeanA[创建完之前]需要用到， 那么Spring就会把这个 还没进行[属性注入] [调用init方法]的BeanA提前暴露给这些Bean，并且把BeanA提到二级缓存中 三级缓存 首先咱们得知道三级缓存包括哪些： DefaultSingletonBeanRegistry#singletonObjects 单例对象的cache 只有[创建完成(只调用了构造方法)]&amp;&amp;[初始化属性完成]的才会放入这里 (这是一级缓存 我们平时说Spring是个大工厂，所有的创建好的bean都可以从Spring缓存里拿。 这里面说的缓存就是一级缓存) DefaultSingletonBeanRegistry#earlySingletonObjects 存放提前曝光的单例对象 只会放入[创建完成(只调用了构造方法)]&amp;&amp; [被提前曝光的] 的bean (用于解决[循环依赖]的2级缓存) DefaultSingletonBeanRegistry#singletonFactories 单例对象工厂的cache 只会放入[创建完成(只调用了构造方法)]的bean (用于解决[循环依赖]的3级缓存) 解决循环依赖核心代码 1234567891011121314151617181920212223242526@Nullableprotected Object getSingleton(String beanName, boolean allowEarlyReference) { //desc 先从singletonObjects（一级缓存）取 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) { //desc 取不到且创建中,那么这里使用同步锁阻塞一会,等待创建完成 //❤这里会发现 当真正创建完bean时会调用addSingletonFactory() 这时候也会锁住singletonObjects❤ synchronized (this.singletonObjects) { //desc 同步阻塞+尝试从earlySingletonObjects(二级缓存)获取 singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null &amp;&amp; allowEarlyReference) { //desc 如果二级缓存取不到&amp;&amp;允许从singletonFactories通过getObject获取 //desc 通过singletonFactory.getObject()(三级缓存)获取工厂创建该bean ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { //desc 通过三级缓存的Factory创建目标bean 并放入2级缓存 singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); } } } } return singletonObject;} 其实这里做的事情和上面原理说的一样: 因为Spring在创建单例BeanA的时候会先把仅仅初始化完成,未注入属性的BeanA(对应图中步骤1)给放到三级缓存中， 如果其他Bean在BeanA创建完之前需要用到(循环依赖就是这种场景)， 那么Spring就会把这个BeanA提前暴露给这些Bean，并且把BeanA提到二级缓存中。 这样子，这些Bean就成功的获取到一个仅仅初始化完成,未注入属性的BeanA 场景分析 假设现在有3个Bean ABC发生了Setter循环依赖(如本文最上面的图) 通过如上方式,，Spring完全可以帮我们解决单例之间的Setter循环依赖问题让循环依赖的Bean之间获取到一个仅仅初始化完成,未注入属性的BeanA 这么说可能有些抽象，咱们尝试来还原该情况发生时发生了什么事情 现在getBeanA，会先去缓存里getA，这时候A还没被创建，故进行A的创建流程 因为A依赖于B，所以A会执行到createBean流程第三步的populateBean，然后会去getB(经过了第二步A已经被放入三级缓存中) 同理，B依赖C，所以B会执行到createBean流程第三步的populateBean，然后会去getC(经过了第二步B已经被放入三级缓存中) C依赖于A，也同理，但是这时候再去getA的时候，会发现又是一个getBeanA流程，但是这时候在三级缓存里getA已经能get到对象了 获取到这个缓存中的A之后，完成beanC的属性注入、初始化等操作。这样，就完成beanC的整个创建流程； 同理，B、A也一样： 这样逐级返回，这样，就完成了整个getBeanA的流程，虽然过程中存在循环依赖，但不会令getBean流程出现异常 至此，Spring完美地给我们处理了Setter循环依赖。 其实，换成代码理解可能更加简单:D 1234567A a = new A();B b = new B();C c = new C();a.setB(b);b.setC(c);c.setA(a); 其它一些补充 为什么构造循环依赖不能被解决（Bean创建过程中没有放入缓存） 参考createBean流程 根据上图的流程，createBeanInstance调用的实际上是构造方法，调用前还没把任何东西放入缓存中。 这时候如果出现基于构造方法的循环依赖，那么是不可能成功的，试想一下： newA的时候依赖于B newB的时候依赖于C newC的时候又反过来依赖于刚才的A 而这时候A还没被new出来！这时候异常就出现了 上述情况换成代码理解就成了 1A a = new A(new B(new C(new A(new ..........)))); 为什么prototype类型的循环依赖无法被解决 首先咱们得先了解下prototype的bean创建流程 graph TD A[createBeanInstance] C[populateBean] E[return Bean] A--调用Bean的构造方法得到一个空Bean-->C C--为Bean注入属性-->E 从流程可见，prototype的Bean创建过程中压根就没有对生成完的bean进行缓存 每一个Bean都是实时创建/使用的 根据上面的流程，我们很容易发现，这种不使用缓存的情况压根不允许存在循环依赖，因为： A依赖于B，这得实时去创建A和B B依赖于C，也得实时去创建C 创建C的时候发现C依赖于A，然鹅A没被缓存（当然，其实prototype压根不会去查缓存） 那这时候程序就会无限循环下去了(当然 spring会检测到这种异常,中断这次getBean) 所以，prototype类型的循环依赖是不能被解决、也不允许出现的 伪代码大致可以理解为： 1A a = new A(new B().setC(new C().setA(new A().setB(......)))); 总结 至此，循环依赖的讨论到此结束。其实，说白了就是： 只有[单例Bean之间]的的循环依赖才能被解决(因为只有单例Bean会被缓存到2级/3级缓存中 用以解决循环依赖) 只有[基于Setter属性注入]循环依赖才能被解决(因为只有基于Setter属性注入的Bean，才能在通过new调用构造方法后，把bean放入2级/3级缓存) [构造注入] 和 [prototype类型的bean]的循环依赖无法被解决 （因为没办法放入2级/3级缓存中）","link":"/Spring/Spring-Circular-Dependencies.html"},{"title":"每天进步一点点","text":"[原创]个人理解，请批判接受，有误请指正。转载请注明出处: https://heyfl.github.io/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day.html 2019-08-22 Spring事务/AOP增强 @EnableAspectJAutoProxy(exposeProxy = true) 进入代理时,通过AopContext.serCurrentProxy(proxy)把当前代理设置到ThreadLocal中 后续在线程销毁(请求结束)前调用代理内部之间的调用就可以通过((AService)AopContext.currentProxy()).b()进行调用了 PS. 性能影响不大 不过实际上代理内部之间还需要AOP增强的场景不多,一般没必要用 Spring LTW实现的静态织入（应该不能叫做代理） 需要添加配置： 代码添加: @EnableLoadTimeWeaving(aspectjWeaving=ENABLED)或&lt;context:load-time-weaver aspectj-weaving=&quot;enable&quot; /&gt; 添加JVM参数-javaagent:类加载器代理路径 LTW(LoadTime Weaving) 加载时织入。在通过JVM加载类时候会先调用ClassTransformer的transform()进行字节码替换后才会进行加载。 静态AOP 通过LTW可以实现静态AOP增强，加载到的类就是已经增强后的代码。这样我们调用方法的时候,直接就是调用了增强后的方法,比起动态代理的调用,更加地高效。 上述流程大致如下所示: graph TD A[Target] B[增强后的字节码] C[加载后的代码] D[注入后的Bean] E[调用方] A--ClassTransformer的transform方法进行字节码植入-->B B--JVM加载-->C C--Spring使用,创建/注入Bean-->D E--方法调用-->D 2019-08-01 Spring事务 对于this.b()这些类实例的内部调用，b()实际上是无事务的 但是可以用((AService)AopContext.currentProxy()).b() 结合@EnableAspectJAutoProxy(exposeProxy = true) 这样b()就包裹在事务里了 2019-7-20 seata seata需要管理所有的数据库操作，不然不能通过前镜像进行回滚 2019-7-17 Spring事务/Cglib final,static,private修饰符无法被增强 由于使用final,static,private修饰符的方法都不能被子类覆盖，相应的，这些方法将不能被实施的AOP增强 增强应该作用在实现类中 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。 2019-5-20 【GC日志】GC耗时解析 【Time: user=0.71 sys=0.01 real=0.02 secs】 user表示：本次GC过程中【所有线程】在用户态消耗的时间总和 sys表示： 本次GC过程中 【所有线程】在内核态所消耗的时间总和 real表示：本次GC过程中，实际GC消耗的时间 2019-5-1 数据库MVCC MVCC：多版本并发控制(Multi-Version Concurrency Control) 优势：查询速度快，并发环境尤是。对于大多数读操作，我们只需要通过MVCC进行简单的查询操作，而不需要获取任何一个锁。 劣势：需要多存储数据。对每一条记录都需要存储所有版本的数据 MVCC只工作在REPEATABLE READ和READ COMMITED隔离级别下 READ UNCOMMITED不是MVCC兼容：因为这个模式只能读取到最新的数据 SERIABLABLE也不与MVCC兼容：因为每个读操作都需要为读到的数据上锁 MVVC机制： 以下摘自《五分钟搞清楚 MVCC 机制》 每一条数据库表记录,都隐藏2个字段 数据行的版本号 （DB_TRX_ID） 删除版本号 (DB_ROLL_PT) 执行insert语句插入的时候,会把当前的事务ID写到该记录的数据行的版本号 （DB_TRX_ID）中: 1234begin;-- 获取到全局事务IDinsert into `test_zq` (`id`, `test_id`) values(&apos;5&apos;,&apos;68&apos;);insert into `test_zq` (`id`, `test_id`) values(&apos;6&apos;,&apos;78&apos;);commit;-- 提交事务 id test_id DB_TRX_ID DB_ROLL_PT 5 68 1 NULL 6 78 1 NULL 修改数据库记录的时候 更新原记录的删除版本号 (DB_ROLL_PT)为当前事务ID 插入一行新的更新后的记录,且它的数据行的版本号 （DB_TRX_ID）为当前事务ID 123begin;-- 获取全局系统事务ID 假设为 10update test_zq set test_id = 22 where id = 5;commit; id test_id DB_TRX_ID DB_ROLL_PT 5 68 1 10 6 78 1 3 5 22 10 NULL 查询的时候需要根据数据行的版本号 （DB_TRX_ID） 和 删除版本号 (DB_ROLL_PT) 二者进行数据数据筛选，需要同时满足以下规则： 数据行的版本号 （DB_TRX_ID） &lt;= 当前事务 删除版本号 (DB_ROLL_PT) &gt; 当前事务 123begin;-- 假设拿到的系统事务ID为 10select * from test_zq;commit; id test_id DB_TRX_ID DB_ROLL_PT 6 22 10 NULL 2019-04-24 Spring的Lifecycle (SpringAppilication生命周期) Spring会拿到所有Lifecycle实现类，然后委托DefaultLifecycleProcessor进行逐个处理 Lifecycle 可以在SpringAppilication在初始化后执行start()方法,Spring停止的时候调用stop()方法 但是单单实现该类不能实现SpringAppilication在启动后,停止时调用Lifecycle对应的方法 这时候我们应该需要使用SmartLifecycle（Lifecycle的子类）,重写isAutoStartup()返回true，才能产生理想效果 2019-04-23 关于测试类的规范 单元测试应该是不依赖于别的单元测试的 所有单元测试应该都得回滚，如果存在异步处理的情况，应尽可能把主线程与fork线程拆成2个测试类方法进行测试 每个测试类／测试方法应写上对应的名称@DisplayName 每个接口，都必须写一个正向测试方法 关于测试类的类名：测试类与被测试的类的路径需要一致，名字也需要对应，如： 123com.fpx.wms.service.impl.InstockServiceImpl↓对应↓com.fpx.wms.service.impl.InstockServiceImplTest 关于测试类的方法名： 方法名尽可能为成功的条件如shouldSuccessAfterPay()，而方法具体用来测试哪个场景的，我们已经使用了@ DisplayName来描述，无须担心 对于结果，需要适应assert断言输出与结 [原创]个人理解，请批判接受，有误请指正。转载请注明出处: https://heyfl.github.io/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day.html 2019-08-22 Spring事务/AOP增强 @EnableAspectJAutoProxy(exposeProxy = true) 进入代理时,通过AopContext.serCurrentProxy(proxy)把当前代理设置到ThreadLocal中 后续在线程销毁(请求结束)前调用代理内部之间的调用就可以通过((AService)AopContext.currentProxy()).b()进行调用了 PS. 性能影响不大 不过实际上代理内部之间还需要AOP增强的场景不多,一般没必要用 2019-08-01 Spring事务 对于this.b()这些类实例的内部调用，b()实际上是无事务的 但是可以用((AService)AopContext.currentProxy()).b() 结合@EnableAspectJAutoProxy(exposeProxy = true) 这样b()就包裹在事务里了 2019-7-20 seata seata需要管理所有的数据库操作，不然不能通过前镜像进行回滚 2019-7-17 Spring事务/Cglib final,static,private修饰符无法被增强 由于使用final,static,private修饰符的方法都不能被子类覆盖，相应的，这些方法将不能被实施的AOP增强 增强应该作用在实现类中 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。 2019-5-20 【GC日志】GC耗时解析 【Time: user=0.71 sys=0.01 real=0.02 secs】 user表示：本次GC过程中【所有线程】在用户态消耗的时间总和 sys表示： 本次GC过程中 【所有线程】在内核态所消耗的时间总和 real表示：本次GC过程中，实际GC消耗的时间 2019-5-1 数据库MVCC 《五分钟搞清楚 MVCC 机制》 每一条数据库表记录,都隐藏2个字段 数据行的版本号 （DB_TRX_ID） 删除版本号 (DB_ROLL_PT) 执行insert语句插入的时候,会把当前的事务ID写到该记录的数据行的版本号 （DB_TRX_ID）中: 1234begin;-- 获取到全局事务IDinsert into `test_zq` (`id`, `test_id`) values(&apos;5&apos;,&apos;68&apos;);insert into `test_zq` (`id`, `test_id`) values(&apos;6&apos;,&apos;78&apos;);commit;-- 提交事务 id test_id DB_TRX_ID DB_ROLL_PT 5 68 1 NULL 6 78 1 NULL 修改数据库记录的时候 更新原记录的删除版本号 (DB_ROLL_PT)为当前事务ID 插入一行新的更新后的记录,且它的数据行的版本号 （DB_TRX_ID）为当前事务ID 123begin;-- 获取全局系统事务ID 假设为 10update test_zq set test_id = 22 where id = 5;commit; id test_id DB_TRX_ID DB_ROLL_PT 5 68 1 10 6 78 1 3 5 22 10 NULL 查询的时候需要根据数据行的版本号 （DB_TRX_ID） 和 删除版本号 (DB_ROLL_PT) 二者进行数据数据筛选，需要同时满足以下规则： 数据行的版本号 （DB_TRX_ID） &lt;= 当前事务 删除版本号 (DB_ROLL_PT) &gt; 当前事务 123begin;-- 假设拿到的系统事务ID为 10select * from test_zq;commit; id test_id DB_TRX_ID DB_ROLL_PT 6 22 10 NULL 2019-04-24 Spring的Lifecycle (SpringAppilication生命周期) Spring会拿到所有Lifecycle实现类，然后委托DefaultLifecycleProcessor进行逐个处理 Lifecycle 可以在SpringAppilication在初始化后执行start()方法,Spring停止的时候调用stop()方法 但是单单实现该类不能实现SpringAppilication在启动后,停止时调用Lifecycle对应的方法 这时候我们应该需要使用SmartLifecycle（Lifecycle的子类）,重写isAutoStartup()返回true，才能产生理想效果 2019-04-23 关于测试类的规范 单元测试应该是不依赖于别的单元测试的 所有单元测试应该都得回滚，如果存在异步处理的情况，应尽可能把主线程与fork线程拆成2个测试类方法进行测试 每个测试类／测试方法应写上对应的名称@DisplayName 每个接口，都必须写一个正向测试方法 关于测试类的类名：测试类与被测试的类的路径需要一致，名字也需要对应，如： 123com.fpx.wms.service.impl.InstockServiceImpl↓对应↓com.fpx.wms.service.impl.InstockServiceImplTest 关于测试类的方法名： 方法名尽可能为成功的条件如shouldSuccessAfterPay()，而方法具体用来测试哪个场景的，我们已经使用了@ DisplayName来描述，无须担心 对于结果，需要适应assert断言输出与结果是否一致（这才能算是一个单元测试） 断言统一使用AssertJ框架，使用Assertions.assertThat()进行处理 2019-04-22 Spring @Lookup 作用 在单例A里 可能依赖到原型类型B,这时候如果用普通的Autowrite不能拿到原型的B，这时候就需要使用@Lockup了 使用参考 参考地址 官网地址参考地址 2019-04-21 架构设计三大原则 合适原则 简单原则 演化原则 即，合适优于先进，简单优于复杂，演化优于一步到位 →能不分，尽可能不分 2019-03-20 策略模式 vs 命令模式 1. 策略模式 1策略模式针对一个命令,多种实现方式 2. 命令模式 1命令模式针对多个命令,每种命令都有各自的实现 3. 总结 1命令模式等于菜单中的复制，移动，压缩等，而策略模式是其中一个菜单的例如复制到不同算法实现。 2019-03-15 策略模式 vs 代理模式 1. 策略模式 1需要调用方告知具体的策略 2. 代理模式 12需要调用方告知使用哪个[代理类]具体的【被代理类】由【代理类】生成，客户端不知道具体被代理的是谁 2.1 动态代理 1需要调用方告知[被代理类]及其接口 3.One More Thing 12以上模式都需要客户端告知具体的[策略]/[代理]/[被代理者]为了使实现其与调用方进行隔离,可以使用[**工厂模式**]进行隔离 2019-03-12 Spring循环依赖 场景现有3个类相互依赖，依赖关系分别为： 1234graph LRA--&gt;BB--&gt;CC--&gt;A 场景细分为3种 构造注入参数循环依赖(报错) 报错 根据Spring初始化方式,Spring容器会按照顺序创建&quot;无属性&quot;的A放到“当前创建Bean池”中，同理再B、C、A，但是在再次创建A的时候发现“当前创建Bean池”已经存在A了，那么这时候会报错循环依赖 Setter注入的循环依赖(单例) 没毛病，在set的时候对象ABC都已经实例化放在Spring缓存了好了 Setter注入的循环依赖(prototype) 报错 prototype修饰的bean不会被Spring缓存,都是使用的时候当场创建的 Spring注入方式选择 结合上面的循环依赖问题，Setter出现问题的概率会低一些 推荐使用Setter注入 构造注入 Setter注入 接口注入(没用过) 2019-03-11 一、集合操作 遍历 Enumeration(JDK1.0) 只提供读集合相关功能，因为没有fail-fast，速度较快一点 Iterator(推荐) 除了读功能，还有删除集合元素的能力，并且支持fail-fast（防止多线程同时对集合修改的一种机制） 修改 正例： 以List为例子,先得获取他的Iterator,通过iterator来进行修改操作 反例： 使用增强型foreach进行add/remove操作： 因为增强型foreach实际上是使用iterator实现的java语法糖: 1234567891011List&lt;String&gt; userNames = new ArrayList&lt;String&gt;() {{ add(\"test1\"); add(\"test12\"); add(\"test13\"); add(\"test14\");}};for (String userName : userNames) { if (userName.equals(\"test12\")) { userNames.remove(userName); }} 编译后 12345678910111213141516List&lt;String&gt; userNames = new ArrayList&lt;String&gt;() { { this.add(\"test1\"); this.add(\"test12\"); this.add(\"test13\"); this.add(\"test14\"); }};Iterator var1 = userNames.iterator();while(var1.hasNext()) { String userName = (String)var1.next(); if (userName.equals(\"test12\")) { userNames.remove(userName); }} 123456所以实际上for (String userName : userNames) 这里每次都会去调用itertor.next()如果你在迭代期间,操作了list.add()和list.remove()等不通过Iterator的操作next()里会去调用checkForComodification()方法然后发现modCount != expectedModCount 抛出异常因为list.add()和list.remove()等不通过Iterator的操作,是不会修改expectedModCount的 其它 fail-fast： 防止多线程同时对集合修改的一种机制 modCount： **List中的一个成员变量。它表示该集合实际被修改的次数 expectedModCount： 是 **List中的一个内部类——Itr中的成员变量 二、Hystrix Feign-starter包含Hystrix以及ribbon(只用他的均衡负载 http请求还是用feign自己的) 一个@FeignClient对应一个线程池或信号量 隔离 线程池隔离 tomcat的请求线程会交给线程池的线程处理 超过线程池会排队或者降级，一个线程池对应的服务挂了，不会影响别的线程池的服务 信号量隔离 只作为开关 并发数超过X服务的信号量,多出来的Tomcat请求将会被拒绝 2019-03-05 一、StringBuilder在高性能场景下的正确用法 StringBuilder在高性能场景下的正确用法 2019-03-01 一、分布式锁 从需求上说，分布式锁要求是不一样的： 如果是用于聊天等社交场景,那么可以使用AP的分布式锁:Redis 如果是用于交易等不允许极端情况下获取锁不一致的，那么AP的Redis锁是不能接受的，这时候一定得用CP的分布式锁,如:etcd Zookeeper这一类 2019-02-22 一、ThreadLocal 每个线程都有一个ThreadLocalMap,ThreadLocalMap以Entry的形式保存着各个线程自己的数据 Entry为一个WeakReference,以你new的ThreadLocal为Key 基于2.当你new的ThreadLocal没被外部强引用时,线程该Thread下对应该ThreadLocal的Entry会在下次GC被回收 2019-02-17 一、常量池 常量池包含: class常量池 存在于class文件中 运行时常量池 存在于方法区中 一个类对应一个运行时常量池 字符串常量池 全局唯一 JDK6存在于方法区(独立于运行时常量池) JDK6以后存在于堆中 二、字符串加载到字符串常量池的2种方式 graph LR A[编译后的class文件中的class常量池] B[运行时常量池*N] C[字符串常量池] D[Java代码运行] A-->B D-->B B-->C 2019-01-28 Mybatis 一级缓存 (范围为一个SqlSession) 有Session/STATEMENT级别: 默认是SESSION 级别，即在一个MyBatis会 话中执行的所有语句，都会共享这一个缓存。 一种是STATEMENT 级别，可以理解为缓存只对当前执行的 这一个Statement 有效 二级缓存 基于mapper 二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享 2018-11-06 一、 分布式事物要看场景的 举个例子: 流量充值涉及到订单支付，金钱交易严格用tcc; 订单支付完后要给用户增加积分，这个必要成功，用最终消息一致性方案; 订单支付完后还要给用户发送一条短信，短信一般是跟电信运营商的第三方接口对接，有可能成功有可能失败，用最大努力通知方案 2018-11-06 一、JVM逃逸分析与TLAB(Thread Local Allocation Buffer) 启动逃逸分析后,会分析没有逃逸的对象,把没有逃逸的对象分配在线程私有的栈里,性能提高5倍 TLAB(默认开启)存在于新生代,默认占其1%,为线程私有;因为线程私有,没有锁开销(对象分配的时候不需要锁住整个堆),效率高; 创建对象时内存分配流程: 逃逸分析,确定分配在哪,如果是分配在堆则2 尽量分配在当前线程的TLAB,不够就去再申请一个TLAB,还不够则3 加锁Eden区,在Eden申请内存,不够则4, 执行Young GC Young GC后,如果还不够,放入老年代 对象分配流程写的不错 参考:https://blog.csdn.net/yangzl2008/article/details/43202969 2018-10-19 一、Feign Consul 获取可用服务IP HealthConsulClient.getHealthServices获取可用IP 通过http://consul.uat.i4px.com:8500/v1/health/service/pds-pos-outer?token= 最终会在ConsulServerUtils.findHost()得到服务所对应的可用IP IP获取逻辑是: 获取Service.Address字段作为可用IP 取不到就取Node.Address 二、Consul 1.服务注销/删除 http://consul.uat.i4px.com:8500/v1/agent/service/deregister/fpx-prs-service-10-104-5-15-8002 2.查看可用服务 http://consul.uat.i4px.com:8500/v1/health/service/wims?passing=true 2018-10-18 一、多服务的【事务】阻塞（跨机器） 数据库锁分为读锁、写锁，读读共享，写写互斥，读写互斥 程序A正在开启事务,操作(包括CRUD) 数据库记录A时,A会被行级锁（读/写锁）; 其它程序若要对进行互斥锁操作,需要阻塞到该锁被释放(程序A提交事务)， 2018-09-29 一、接口返回的JSON数据,快速转换为实际数据 ObjectMapper mapper = new ObjectMapper(); SimsPudo simsPudo = mapper.convertValue(responseMessage.getData(), SimsPudo.class); 2018-09-29 一、-XX:+PrintFlagsFinal :=意味着值是被修改的, =表示默认值 2018-09-29 一、Feign重试 默认只会对connect timeout进行重试 OKToRetryOnAllOperations=true 会对connect timeout和socket read timeout都进行重试,对socket read timeout会引起后端重复处理请求问题(需要做幂等) Feign对于&gt;400的后端报错是不会重试的 设置了OKToRetryOnAllOperations=true所有后端需要幂等 OKToRetryOnAllOperations=false的前端需要做对应的超时异常处理,如: i.写代码自动重试 ii.直接返回前台成功 二、超时时间 (socket)connect timeout 连接超时 (socket)read timeout 读超时 对read timout,请求已经到达后端处理,但是没在指定时间内返回 三、Http状态码分类 1XX:正在处理 2XX:请求处理成功 3XX:请求需要重定向 4XX:服务器无法处理请求(U Fuck Off) 5XX:服务器处理请求出错(I Fuck Off) 四、String “ABC”: 是显示声明的 以&quot;ABC&quot;形式存在于常量池中(常量池也在堆里) new String(“ABC”): 以对象形式存在于堆中 str.intern(),字符串(或引用)是否存在于常量池,不存在就把该引用存在常量池 “ABC”.intern() 没意思,本来就是放在常量池的东西,再调intern没用 五、@Transaction @Transactional方法会覆盖类上的配置 调用被注入的代理类才能有效地激活@Transaction的效果 2018-09-28 一、JVM参数配置 -XX:+PrintCommandLineFlags 打印改动过的JVM参数 -XX:+PrintFlagsFinal打印最终在用的参数 -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions 显示隐藏参数 二、Feign前后端全局异常处理 后端【业务代码直接抛异常】 后端全局异常捕获时【返回带异常信息的ResponseMsg】(一般不含堆栈信息),同时返回状态码设置为500(也可以404,因为Feign默认后端报错就是返回404) 前端(调用者)ErrorDecode时,解析该[ResponseMsg的异常信息],重新throw对应的异常就能保证前后端异常一致了 [x] 对于需要进入fallback的调用 同上处理,但是按需可能需要使用FallbackFactory获取后端返回的异常信息进一步处理 如打印日志等 [ ] 问题:可能导致前端(调用方)不能切换实例重试 [ ] 加入Decode404=true后,404错误不会进入ErrorDecode和Fallback 2018-09-17 一、正确的kill进程 先kill -15(安全关闭 回收资源) 不行再kill -9(强制关闭) 2018-09-16 一、JDK8+移除了Perm jdk8移除了Perm 其方法区及常量池等数据,全部移到了元数据区(Metaspace)中 二、String.intern JDK7及以后版本,是复制其字符串引用到常量池中 实际数据还是存在于堆中 二、-XX:MetaspaceSize -XX:MetaspaceSize=200m不是初始元空间大小,而是达到了200m后才会对该区域进行GC 2018-09-06 一、获取全局唯一ID redis: 服务器时间戳+redis全局自增id=&gt;UUID 简单、快捷 zk:同上 比较慢 通过数据库 慢、并发低 twitter的雪花算法: 通过时间戳+机器ID=&gt;UUID 优势:速度快、无需依赖中间件、全局唯一 实现参考：https://github.com/souyunku/SnowFlake 2018-09-05 一、SQL的强制索引 select * from parcel FORCE INDEX(uniq_fpx_tracking_no_1) where fpx_tracking_no not in (‘901000486441’,‘901000497454’) ; 二、接口幂等理解 分布式锁实现幂等的方式 查询缓存结果,存在就返回 不存在,获取分布式锁(阻塞等待) 再尝试第一步 不存在,开始执行业务逻辑,并且缓存结果 释放锁 分布式锁实现的幂等,不完全可靠,因为缓存会过期 要保证其绝对可靠,还是得使用select+insert、唯一索引等方式 三、IO多路复用模型 https://mp.weixin.qq.com/s/xmSn9Xz6MiFb2s_0J7iXwQ 单Reactor单线程(Redis) 单Reactor多线程 多Reactor多线程","link":"/Make-A-Little-Progress-Every-Day/Make-A-Little-Progress-Every-Day.html"}],"tags":[{"name":"BUG","slug":"BUG","link":"/tags/BUG/"},{"name":"Spring-Cloud","slug":"Spring-Cloud","link":"/tags/Spring-Cloud/"},{"name":"Consul","slug":"Consul","link":"/tags/Consul/"},{"name":"事务","slug":"事务","link":"/tags/事务/"},{"name":"分布式","slug":"分布式","link":"/tags/分布式/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"JVM内存结构","slug":"JVM内存结构","link":"/tags/JVM内存结构/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"redis集群","slug":"redis集群","link":"/tags/redis集群/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"源码分析","slug":"源码分析","link":"/tags/源码分析/"},{"name":"每天进步一点点","slug":"每天进步一点点","link":"/tags/每天进步一点点/"}],"categories":[{"name":"about","slug":"about","link":"/categories/about/"},{"name":"redis","slug":"redis","link":"/categories/redis/"},{"name":"Bug-Log","slug":"Bug-Log","link":"/categories/Bug-Log/"},{"name":"JVM","slug":"JVM","link":"/categories/JVM/"},{"name":"Distributed","slug":"Distributed","link":"/categories/Distributed/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"Make-A-Little-Progress-Every-Day","slug":"Make-A-Little-Progress-Every-Day","link":"/categories/Make-A-Little-Progress-Every-Day/"}]}